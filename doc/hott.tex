\documentclass{amsart}

\usepackage{amssymb}
\usepackage[all]{xy}
\usepackage{verbatim}
\usepackage{ifthen}
\usepackage{xargs}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage{mathrsfs}

\providecommand\WarningsAreErrors{false}
\ifthenelse{\equal{\WarningsAreErrors}{true}}{\renewcommand{\GenericWarning}[2]{\GenericError{#1}{#2}{}{This warning has been turned into a fatal error.}}}{}

\newcommand{\newref}[4][]{
\ifthenelse{\equal{#1}{}}{\newtheorem{h#2}[hthm]{#4}}{\newtheorem{h#2}{#4}[#1]}
\expandafter\newcommand\csname r#2\endcsname[1]{#3~\ref{#2:##1}}
\expandafter\newcommand\csname R#2\endcsname[1]{#4~\ref{#2:##1}}
\newenvironmentx{#2}[2][1=,2=]{
\ifthenelse{\equal{##2}{}}{\begin{h#2}}{\begin{h#2}[##2]}
\ifthenelse{\equal{##1}{}}{}{\label{#2:##1}}
}{\end{h#2}}
}

\newref[section]{thm}{theorem}{Theorem}
\newref{lem}{lemma}{Lemma}
\newref{prop}{proposition}{Proposition}
\newref{cor}{corollary}{Corollary}

\theoremstyle{definition}
\newref{defn}{definition}{Definition}
\newref{example}{example}{Example}

\theoremstyle{remark}
\newref{remark}{remark}{Remark}

\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand{\D}{\mathsf{D}}
\newcommand{\bbG}{\mathbb{G}}
\newcommand{\Set}{\cat{Set}}
\newcommand{\PSh}[1]{\Set^{#1^{op}}}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\glob}{\PSh{\bbG}}
\newcommand{\ocat}{\omega \cat{Cat}}
\newcommand{\Dn}[1][n]{\mathrm{D}^{#1}}
\newcommand{\dDn}[1][n]{\mathrm{\partial D}^{#1}}

\newcommand{\pb}[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}
\newcommand{\po}[1][dr]{\save*!/#1+1.2pc/#1:(1,-1)@^{|-}\restore}

\numberwithin{table}{section}

\begin{document}

\title{Homotopy Type Theory}

\author{Valery Isaev}

\begin{abstract}
In this paper, we give a description of an evaluation algorithm for homotopy type theory.
\end{abstract}

\maketitle

\section{Introduction}

\section{Cellular sets}

In this section, we will recall the definition of cellular sets.

\begin{defn}
A \emph{globular set} is a presheaf on the category $\bbG$, whose objects are natural numbers and morphisms are generated from
$\sigma_n,\tau_n : n \to n + 1$ subject to the equations
$\sigma_{n+1} \circ \sigma_n = \tau_{n+1} \circ \sigma_n$, $\sigma_{n+1} \circ \tau_n = \tau_{n+1} \circ \tau_n$.
A morphism of globular sets is a morphism of presheaves.
\end{defn}

Explicitly, a globular set is a sequence of sets $X_n$ together with maps $s_k,t_k : X_n \to X_k$ for each $k < n$ subject to equations.
Elements of $X_n$ are called $n$-cells. Given $n$-cell $x$, cells $s_k(x)$ and $t_k(x)$
are called the ($k$-dimensional) source and the target of $x$ respectively.
A pair of $n$-cells $x$ and $y$ are \emph{parallel} if $s_k(x) = s_k(y)$ and $t_k(x) = t_k(y)$ for each $k < n$.
The expression $x : a \to b$ stands for the following:
there is $n \in \nats$ such that $a$ and $b$ are (necessarily parallel) $n$-cells,
$x$ is an $(n+1)$-cell, $s_n(x) = a$, and $t_n(x) = b$.

For each $n \in \nats$, the globular set $\bbG(-,n)$ is denoted by $\Dn$.
The globular sets $\dDn$ together with the maps $\dDn \to \Dn$ are defined by induction on $n$.
$\dDn[0]$ is the initial object, and $\dDn[0] \to \Dn[0]$ is the unique morphism.
$\dDn[n+1]$ is the pushout $\Dn \amalg_{\dDn} \Dn$, and $\dDn[n+1] \to \Dn[n+1]$
is induced by the maps $(\sigma_n \circ -)$ and $(\tau_n \circ -)$.

\begin{defn}
A \emph{strict $\omega$-category} is a globular set equipped with the following operations.
\begin{itemize}
\item For each $n$-cell $x$, an $(n+1)$-cell $id_x : x \to x$ called the \emph{identity} on $x$.
\item For each $n,k \in \nats$ and for each pair of $n$-cells $x$,$y$ such that
$t_k(x) = s_k(y)$ (in this case we say $x$ and $y$ are \emph{$k$-composable}),
an $n$-cell $y *_k x$ called \emph{k-composite} of $x$ and $y$.
\end{itemize}
We often regard an $n$-cell $x$ as a cell of a dimension higher than $n$ iteratively applying $id$ to $x$.

The operations above must satisfy the following properties.
\begin{itemize}
\item If $x : a \to b$, $y : b \to c$ is a pair of $n$-composable $(n+1)$-cells, then $y *_n x : a \to c$.
\item If $k < n$ and $x : a \to b$, $y : c \to d$ is a pair of $k$-composable $(n+1)$-cells, then $y *_k x : c *_k a \to d *_k b$.
\item If $x,y,z$ are $n$-cells, then $(z *_k y) *_k x = z *_k (y *_k x)$, whenever it makes sense.
\item If $k < n$ and $x$ is an $n$-cell, then $t_k(x) *_k x = x = x *_k s_k(x)$.
\item If $k < n$ and $x$,$y$ is a pair of $k$-composable $n$-cells, then $id_y *_k id_x = id_{y *_k x}$.
\item If $x$,$y$,$z$,$u$ are $n$-cells and $m < k < n$, then $(x *_k y) *_m (z *_k u) = (x *_m z) *_k (y *_m u)$, whenever it makes sense.
\end{itemize}

An $\omega$-functor between a pair of $\omega$-categories is a morphism of
the underlying globular sets commuting with compositions and identities.
The category $\ocat$ has $\omega$-categories as objects and $\omega$-functors as morphisms.
\end{defn}

The forgetful functor $U : \ocat \to \glob$ has a left adjoint $F : \glob \to \ocat$.
Let us denote by $(T : \glob \to \glob, \eta_X : X \to T(X), \mu_X : T T(X) \to T(X))$ the monad $U \circ F$,
and by $\dDn_T$ and $\Dn_T$ the $\omega$-categories $T(\dDn)$ and $T(\Dn)$.

An \emph{$n$-dimensional pasting diagram} is defined by induction on $n$.
There is exactly one $0$-dimensional pasting diagram, which is denoted by $\diamond$.
An $(n+1)$-dimensional pasting diagram is a finite sequence of $n$-dimensional pasting diagrams.

With each $n$-dimensional pasting diagram $\pi$ we associate an $n$-dimensional globular set $\widehat{\pi}$.
If $\pi$ is the unique $0$-dimensional pasting diagram, then $\widehat{\pi}$ is the terminal $0$-dimensional globular set.
If $\pi = (\pi^1, \ldots \pi^k)$, then let $\widehat{\pi}_0 = \{0, 1, \ldots k\}$
and $\widehat{\pi}_{m+1} = \coprod \limits_{i = 1}^k \widehat{\pi^i}_m$.
For each $k > 0$, the source and the target are defined in the evident way,
and for each $x \in \widehat{\pi^i}$, we define $s_0(x) = i - 1$ and $t_0(x) = i$.

\begin{defn}
The category $\Theta$ has pasting diagrams as objects, and the set of morphisms between $\pi_1$ and $\pi_2$
is the set of morphisms between strict $\omega$-categories $T(\widehat{\pi_1})$ and $T(\widehat{\pi_2})$.
That is, $\Theta$ is a full subcategory of $\ocat$.
A cellular set is a presheaf on $\Theta$, a morphism of cellular sets is a morphism of presheaves.
\end{defn}

\section{Syntax and Inference Rules}

First, let us define the sets of raw terms and contexts:
\[ Tm ::= v_i\ |\ U_\alpha\ |\ \Pi\,A\,B\ |\ \lambda b\ |\ b\ a\ |\ \Sigma\,A\,B\ |\ a , b\ |\ proj_1\ p\ |\ proj_2\ p\ | \]
\[ (a = a'\,|\,A)\ |\ idp\ a\ |\ pmap\ b\ a\ |\ inv\ p\ |\ comp\ p\ q\ |\ coe\ p\ |\ pcon\ t\ |\ pdec\ t, \]
\[ Ctx ::= \epsilon\ |\ \Gamma, A, \]
where $i \in \Z$, $\alpha \in \nats$, $\Gamma \in Ctx$, and $a, a', b, p, q, t, A, B \in Tm$.
Similarly to \cite{norm}, we use de Bruijn's representation of lambda terms.

The meaning of each term should be clear from the inference rules listed in table \ref{table:inf-rules}.
Note that we do not use reduction rules, instead we define terms to be computationally equal if their interpretations coincide.
Thus inference rules depend on the evaluation function $\llbracket - \rrbracket$ that will be defined in section \ref{sec:eval}.

We write $\Pi_1 A\,B$ for $pmap\,(pmap\,(\lambda \lambda \Pi\,v_1\,(v_1\,v_0))\,A)\,(\lambda B)$.

\centerAlignProof

\begin{table}
\begin{center}
\AxiomC{}
\UnaryInfC{$\epsilon \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\UnaryInfC{$\Gamma, A \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $0 \leq i < | \Gamma |$}
\UnaryInfC{$\Gamma \vdash v_i : \Gamma(i)$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $\alpha < \beta$}
\UnaryInfC{$\Gamma \vdash U_\alpha : U_\beta$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\BinaryInfC{$\Gamma \vdash \Pi A B : U_{max(\alpha,\beta)}$}
\DisplayProof
\quad
\AxiomC{$\Gamma, A \vdash b : B$}
\UnaryInfC{$\Gamma \vdash \lambda b : \Pi A B$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash b : \Pi A B$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash b\ a : B[a]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\BinaryInfC{$\Gamma \vdash \Sigma\,A\,B : U_{max(\alpha,\beta)}$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B[a]$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\TrinaryInfC{$\Gamma \vdash a, b : \Sigma\,A\,B$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : \Sigma\,A\,B$}
\UnaryInfC{$\Gamma \vdash proj_1\ p : A$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash p : \Sigma\,A\,B$}
\UnaryInfC{$\Gamma \vdash proj_2\ p : B[proj_1\ p]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : A = B \,|\, idp\ U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B$}
\TrinaryInfC{$\Gamma \vdash a = b \,|\, p : U_\alpha$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash a : A$}
\UnaryInfC{$\Gamma \vdash idp\ a : a = a\,|\, idp\ A$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash b : b_0 = b_1\,|\,\Pi_1\,A\,B$}
\AxiomC{$\Gamma \vdash a : a_0 = a_1\,|\,A$}
\BinaryInfC{$\Gamma \vdash pmap\ b\ a : b_0\ a_0 = b_1\ a_1\,|\,B[a]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash P : A = B \,|\, U_\alpha$}
\noLine
\UnaryInfC{$\Gamma \vdash Q : B = C \,|\, U_\alpha$}
\AxiomC{$\Gamma \vdash p : a = b \,|\, P$}
\noLine
\UnaryInfC{$\Gamma \vdash q : b = c \,|\, Q$}
\BinaryInfC{$\Gamma \vdash comp\ p\ q : a = c \,|\, comp\ P\ Q$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : a = b \,|\, P$}
\UnaryInfC{$\Gamma \vdash inv\ p : b = a \,|\, inv\ P$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash p : A = B \,|\, idp\ U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash coe\ p\ a : B$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash t : comp\ p\ a' = comp\ a\ p' \,|\, idp\ (a_0 = a_1 \,|\, A)$}
\UnaryInfC{$\Gamma \vdash pcon\ t : p = p' \,|\, Id_1 A\,a\,a'$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash t : p = p' \,|\, Id_1 A\,a\,a'$}
\UnaryInfC{$\Gamma \vdash pdec\ t : comp\ p\ a' = comp\ a\ p' \,|\, idp\ (a_0 = a_1 \,|\, A)$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B : U_\beta$}
\RightLabel{, $\llbracket A \rrbracket^{\rho_\Gamma}_0 = \llbracket B \rrbracket^{\rho_\Gamma}_0$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{center}

\bigskip
\caption{Inference rules.}
\label{table:inf-rules}
\end{table}

\section{Evaluation}
\label{sec:eval}

We work in a suitable category of domains (see, for example, \cite{domains} for more information on the topic).
Let $TM$ be the set of functions $\nats \to Tm$, $Ob(\bbG)$ the set of objects,
and $Hom(\bbG)$ the set of morphisms of the category $\bbG$, thus $Ob(\bbG)$ is simply the set of natural numbers.
Let $(\D,\sqsubseteq)$ be a domain satisfying the following equation:
\[ \D = [Hom(\bbG)_\bot \times \D \to \D] \oplus \D \times \D \oplus (\omega + 1)_\bot \]
\[ \oplus [\nats_\bot \to \D \times \D] \times TM_\bot \times \nats_\bot \oplus Ob(\bbG)_\bot \times \D \times \D \times \D \]
\[ \oplus Ob(\bbG)_\bot \times \D \times [Hom(\bbG)_\bot \times \D \to \D] \]
\[ \oplus Ob(\bbG)_\bot \times \D \times [Hom(\bbG)_\bot \times \D \to \D] \]

Here, $\omega + 1$ denotes the set $\nats \cup \{ \omega \}$.
The meaning of the components in this equaltion should be clear from the names of the constructors:
\begin{itemize}
\item[] $\mathsf{Lam} : [Hom(\bbG)_\bot \times \D \to \D] \to \D$
\item[] $\mathsf{Pair} : \D \times \D \to \D$
\item[] $\mathsf{U} : (\omega + 1)_\bot \to \D$
\item[] $\mathsf{Ne} : [\nats_\bot \to \D \times \D] \times TM_\bot \times \nats_\bot \to \D$
\item[] $\mathsf{Id} : Ob(\bbG)_\bot \times \D \times \D \times \D \to \D$
\item[] $\mathsf{Pi} : Ob(\bbG)_\bot \times \D \times [Hom(\bbG)_\bot \times \D \to \D] \to \D$
\item[] $\mathsf{Sigma} : Ob(\bbG)_\bot \times \D \times [Hom(\bbG)_\bot \times \D \to \D] \to \D$
\end{itemize}

Let $Env$ be the domain $[\nats_\bot \to \D]$.
If $\rho \in Env$ and $x \in \D$, then we define $\rho[x] \in Env$ to be the function defined by the following rules: $\rho[x](0) = x$ and $\rho[x](i+1) = \rho(i)$.
Now, we define the evaluation function:
\begin{itemize}
\item[] $\llbracket - \rrbracket : Tm_\bot \times Env \times Ob(\bbG)_\bot \to \D$
\item[] $\llbracket v_i \rrbracket^\rho_n = \rho(i)$, if $i \geq 0$, and $\bot$, otherwise.
\item[] $\llbracket U_\alpha \rrbracket^\rho_n = \mathsf{U}(\alpha)$, if $\alpha \in \nats$, and $\bot$, otherwise.
\item[] $\llbracket \Pi A B \rrbracket^\rho_n = \mathsf{Pi}(n, \llbracket A \rrbracket^\rho_n, (m, a) \mapsto \llbracket B \rrbracket^{(\mathsf{action}(m,-) \circ \rho)[a]}_{dom(m)})$
\item[] $\llbracket \Sigma A B \rrbracket^\rho_n = \mathsf{Sigma}(n, \llbracket A \rrbracket^\rho_n, (m, a) \mapsto \llbracket B \rrbracket^{(\mathsf{action}(m,-) \circ \rho)[a]}_{dom(m)})$
\item[] $\llbracket a = a' | A \rrbracket^\rho_n = \mathsf{Id}(n, \llbracket A \rrbracket^\rho_n, \llbracket a \rrbracket^\rho_n, \llbracket a' \rrbracket^\rho_n)$
\item[] $\llbracket \lambda b \rrbracket^\rho_n = \mathsf{Lam}((m, a) \mapsto \llbracket b \rrbracket^{(\mathsf{action}(m,-) \circ \rho)[a]}_{dom(m)})$
\item[] $\llbracket b\ a \rrbracket^\rho_n = \mathsf{app}(n, \llbracket b \rrbracket^\rho_n, \llbracket a \rrbracket^\rho_n)$
\item[] $\llbracket a, b \rrbracket^\rho_n = \mathsf{Pair}(\llbracket a \rrbracket^\rho_n, \llbracket b \rrbracket^\rho_n)$
\item[] $\llbracket proj_1\ p \rrbracket^\rho_n = \mathsf{proj_1}(\llbracket p \rrbracket^\rho_n)$
\item[] $\llbracket proj_2\ p \rrbracket^\rho_n = \mathsf{proj_2}(\llbracket p \rrbracket^\rho_n)$
\item[] $\llbracket idp\ a \rrbracket^\rho_n = \mathsf{action}(\delta_n, \llbracket a \rrbracket^\rho_n)$
\item[] $\llbracket \Pi_1 A B \rrbracket^\rho_n = \mathsf{Pi}(n + 1, \llbracket A \rrbracket^\rho_n, (m, a) \mapsto \llbracket B \rrbracket^{(\mathsf{action}(m,-) \circ \rho)[a]}_{dom(m)})$
\item[] $\llbracket pmap\ b\ a \rrbracket^\rho_n = \mathsf{app}(n + 1, \llbracket b \rrbracket^\rho_n, \llbracket a \rrbracket^\rho_n)$
\end{itemize}

Functions $\mathsf{app}$, $\mathsf{proj_1}$, $\mathsf{proj_2}$, and $\mathsf{action}$ are defined as follows:
\begin{itemize}
\item[] $\mathsf{app} : Ob(\bbG)_\bot \times \D \times \D \to \D$
\item[] $\mathsf{app}(n,\mathsf{Lam}(f),a) = f(id_n,a)$
\item[] $\mathsf{app}(n,e,a) = \bot$, otherwise
\item[]
\item[] $\mathsf{proj_1} : \D \to \D$
\item[] $\mathsf{proj_1}(\mathsf{Pair}(a,b)) = a$
\item[] $\mathsf{proj_1}(x) = \bot$, otherwise
\item[]
\item[] $\mathsf{proj_2} : \D \to \D$
\item[] $\mathsf{proj_2}(\mathsf{Pair}(a,b)) = b$
\item[] $\mathsf{proj_2}(x) = \bot$, otherwise
\item[]
\item[] $\mathsf{action} : Hom(\bbG)_\bot \times \D \to \D$
\item[] $\mathsf{action}(m, \mathsf{Lam}(f)) = \mathsf{Lam}((m',x) \mapsto f(m \circ m', x))$
\item[] $\mathsf{action}(m, \mathsf{Pair}(a, b)) = \mathsf{Pair}(\mathsf{action}(m, a), \mathsf{action}(m, b))$
\item[] $\mathsf{action}(m, \mathsf{U}(\alpha)) = \mathsf{U}(\alpha)$
\item[] $\mathsf{action}(m, \mathsf{Ne}(s,e,c)) = TODO$
\item[] $\mathsf{action}(m, \mathsf{Id}(n, A, a, a')) = \mathsf{Id}(dom(m), \mathsf{action}(m, A), \mathsf{action}(m, a), \mathsf{action}(m, a'))$
\item[] $\mathsf{action}(m, \mathsf{Pi}(n, A, B)) = \mathsf{Pi}(dom(m), \mathsf{action}(m, A), (m', x) \mapsto B(m \circ m', x))$
\item[] $\mathsf{action}(m, \mathsf{Sigma}(n, A, B)) = \mathsf{Sigma}(dom(m), \mathsf{action}(m, A), (m', x) \mapsto B(m \circ m', x))$
\item[]
\item[] $\mathsf{comp} : Ob(\bbG)_\bot \times \D \times \D \to \D$
% \item[] $\mathsf{comp}(n, \mathsf{Idp}(x, y, d), \mathsf{Idp}(x', y', e)) = \mathsf{Idp}(\mathsf{comp}(n - 1, d, e))$, if $n > 0$
\item[] $\mathsf{comp}(n, d, e) = TODO$
\end{itemize}

Let $\mathscr{P}(\D)$ denote the set of subset of $\D$.
If $n \in \nats$, $R \in \mathscr{P}(\D)$, and $Q : \D \to \mathscr{P}(\D)$,
then define $\mathcal{S}igma\,R\,Q, \mathcal{P}i_n R\,Q, \mathcal{N}\!e \in \mathscr{P}(\D)$ as follows:
\[ \mathcal{S}igma\,R\,Q = \{ \mathsf{Pair}(a,b) \in \D\,|\,a \in R, b \in R(a) \}, \]
\[ \mathcal{P}i_n R\,Q = \{ \mathsf{Lam}(f) \in \D\,|\,f(id_n,a) \in Q(a) \text{ for all } a \in R \}, \]
\[ \mathcal{N}\!e = \{ \mathsf{Ne}(s,e,c)\,|\,e \in TM \}, \]
% \[ \mathcal{I}d\ A = \mathcal{N}\!e \cup \{ \mathsf{Idp}(d)\,|\,d \in A \}. \]

Now, for each $\alpha \leq \omega$ and $n \in \nats$,
we define $\mathcal{U}^\alpha_n \in \mathscr{P}(\D)$ and a function $[-]^\alpha_n : \mathcal{U}^\alpha_n \to \mathscr{P}(\D)$ by induction on $\alpha$.
First, we define a relation $G^\alpha_n \subseteq \D \times \mathscr{P}(\D)$ inductively by the following rules:
\medskip
\begin{center}
\AxiomC{$(A, R) \in G^\alpha_n$}
\AxiomC{$(B(id_n, a), Q(a)) \in G^\alpha_n$ for all $a \in R$}
\BinaryInfC{$(\mathsf{Sigma}(n, A, B), \mathcal{S}igma\,R\,Q) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$(A, R) \in G^\alpha_n$}
\AxiomC{$(B(id_n, a), Q(a)) \in G^\alpha_n$ for all $a \in R$}
\BinaryInfC{$(\mathsf{Pi}(n, A, B), \mathcal{P}i_n R\,Q) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$(A,R) \in G^\alpha_{n+1}$}
\UnaryInfC{$(\mathsf{Id}(n, A, a, a'), \mathcal{I}d_n R\,a\,a') \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{}
\UnaryInfC{$(\mathsf{Ne}(s,e,c), \mathcal{N}\!e) \in G^\alpha_n$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{, $\beta < \alpha$}
\UnaryInfC{$(\mathsf{U}(\beta), \mathcal{U}^\beta_n) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

We inductively define $\mathcal{U}^\alpha_n \in \mathscr{P}(\D)$ by the following rules:
\medskip
\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_n$}
\AxiomC{$B(id_n, a) \in \mathcal{U}^\alpha_n$ for all $a \in [A]^\alpha_n$}
\BinaryInfC{$\mathsf{Sigma}(n, A, B) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_n$}
\AxiomC{$B(id_n, a) \in \mathcal{U}^\alpha_n$ for all $a \in [A]^\alpha_n$}
\BinaryInfC{$\mathsf{Pi}(n, A, B) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_{n + 1}$}
\AxiomC{$a \in [\mathsf{action}(\sigma_n, A)]^\alpha_n$}
\AxiomC{$a' \in [\mathsf{action}(\tau_n, A)]^\alpha_n$}
\TrinaryInfC{$\mathsf{Id}(n, A, a, a') \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$s(i) \in \mathcal{U}^\alpha_i \times \mathcal{U}^\alpha_i$ for all $0 \leq i < n$}
\UnaryInfC{$\mathsf{Ne}(s,e,c) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\quad
\centerAlignProof
\AxiomC{}
\RightLabel{, $\beta < \alpha$}
\UnaryInfC{$\mathsf{U}(\beta) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip
We write simply $\mathcal{U}_n$ and $[-]_n$ for $\mathcal{U}^\omega_n$ and $[-]^\omega_n$.

\begin{lem}
For each $\alpha \leq \omega$ and $n \in \nats$, the graph $G^\alpha_n$ defines a partial function, that is $(A, R), (A, R') \in G^\alpha_n$ implies $R = R'$.
For each $\alpha \leq \omega$ and $n \in \nats$, the partial function $[-]^\alpha_n : \D \to \mathscr{P}(\D)$
defined by the graph $G^\alpha_n$ is defined on $\mathcal{U}^\alpha_n \subseteq \D$.
\end{lem}
\begin{proof}
The first statement is proved by induction on generation of $G^\alpha$ and the second by induction on generation of $\mathcal{U}^\alpha$.
\end{proof}

For each $n \in \nats$ and context $\Gamma$ (that is, finite sequence of terms), we define its interpretation $[\Gamma]_n \subseteq Env$ as follows:
$\rho \in [\Gamma]_n$ if and only if $\rho(i) \in [\llbracket \Gamma(i) \rrbracket^\rho_n]_n$ for each $0 \leq i < |\Gamma|$ and $n \in \nats$.
We define a predicate on contexts $\Gamma \models$ inductively as follows:

\centerAlignProof

\medskip
\begin{center}
\AxiomC{}
\UnaryInfC{$\epsilon \models$}
\DisplayProof
\quad
\AxiomC{$\Gamma \models$}
\AxiomC{$\llbracket A \rrbracket^\rho_n \in \mathcal{U}_n$ for all $n \in \nats$ and $\rho \in [\Gamma]_n$}
\BinaryInfC{$\Gamma, A \models$}
\DisplayProof
\end{center}
\medskip

We write $\Gamma \models a : A$ if and only if $\Gamma \models$,
$\forall \rho \in [\Gamma]_n, \llbracket A \rrbracket^\rho_n \in \mathcal{U}_n$,
and $\forall \rho \in [\Gamma]_n, \llbracket a \rrbracket^\rho_n \in [\llbracket A \rrbracket^\rho_n]_n$.

\begin{prop}
If $\Gamma \vdash$, then $\Gamma \models$.
If $\Gamma \vdash a : A$, then $\Gamma \models a : A$.
\end{prop}
\begin{proof}
By induction on the derivation.
Most of the cases are straightforward, let us prove some of them:
\begin{itemize}
\item Case
\AxiomC{$\Gamma, A \vdash b : B$}
\UnaryInfC{$\Gamma \vdash \lambda b : \Pi A B$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash b : \Pi A B$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash b\ a : B[a]$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash p : A = B\,|\,idp\ U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B$}
\TrinaryInfC{$\Gamma \vdash a = b\,|\,p : U_\alpha$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash a : A$}
\UnaryInfC{$\Gamma \vdash idp\ a : a = a\,|\,idp\ A$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B : U_\beta$}
\RightLabel{, $\llbracket A \rrbracket^{\rho_\Gamma}_0 = \llbracket B \rrbracket^{\rho_\Gamma}_0$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{itemize}
\end{proof}

Now, let us show how to reify elements of $\D$ into terms.
\begin{itemize}
\item[] $\mathsf{reify} : \nats_\bot \times \D \times \D \to Tm_\bot$
\item[] $\mathsf{reify}(i, \mathsf{Lam}(f), \mathsf{Pi}(0, A, B)) = \lambda\,\mathsf{reify}(i + 1, f(id_0, x), B(id_0, x))$, \\
        \indent where $x = \mathsf{reflect}(k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, \mathsf{Pair}(a, b), \mathsf{Sigma}(0, A, B)) = \mathsf{reify}(i, a, A), \mathsf{reify}(i, b, B(id_0, a))$
\item[] $\mathsf{reify}(i, \mathsf{U}(\alpha), \mathsf{U}(\beta)) = U_\alpha$, if $\alpha < \beta$
\item[] $\mathsf{reify}(i, \mathsf{Ne}(s, e, c), t) = e(i)$
\item[] $\mathsf{reify}(i, \mathsf{Id}(0, A, a, a'), \mathsf{U}(\alpha)) = (\mathsf{reify}(i, a, A) = \mathsf{reify}(i, a', A)\,|\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))$)
\item[] $\mathsf{reify}(i, \mathsf{Pi}(0, A, B), \mathsf{U}(\alpha)) =$
        $\Pi\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))\,\mathsf{reify}(i + 1, B(id_0, x), \mathsf{U}(\alpha))$, \\
        \indent where $x = \mathsf{reflect}(k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, \mathsf{Sigma}(0, A, B), \mathsf{U}(\alpha)) = $
        $\Sigma\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))\,\mathsf{reify}(i + 1, B(id_0, x), \mathsf{U}(\alpha))$, \\
        \indent where $x = \mathsf{reflect}(k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, e, t) = \bot$, otherwise.
\item[]
\item[] $\mathsf{reflect} : TM_\bot \times \D \to \D$
\item[] $\mathsf{reflect}(e,\mathsf{Pi}(0, A, B)) = \mathsf{Lam}((m, a) \mapsto \mathsf{reflect}(k \mapsto e(k)\ \mathsf{reify}(0, a, A), B(id_0, a)))$
\item[] $\mathsf{reflect}(e,\mathsf{Sigma}(0, A, B)) = \mathsf{Pair}(a, \mathsf{reflect}(k \mapsto proj_2\ e(k), B(id_0, a)))$, \\
        \indent where $a = \mathsf{reflect}(k \mapsto proj_1\ e(k), A)$
\item[] $\mathsf{reflect}(e,t) = Ne(n \mapsto \bot, e, 0)$, otherwise
\end{itemize}

\bibliographystyle{amsplain}
\bibliography{ref}

\end{document}
