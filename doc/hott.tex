\documentclass{amsart}

\usepackage{amssymb}
\usepackage[all]{xy}
\usepackage{verbatim}
\usepackage{ifthen}
\usepackage{xargs}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage{mathrsfs}

\providecommand\WarningsAreErrors{false}
\ifthenelse{\equal{\WarningsAreErrors}{true}}{\renewcommand{\GenericWarning}[2]{\GenericError{#1}{#2}{}{This warning has been turned into a fatal error.}}}{}

\newcommand{\newref}[4][]{
\ifthenelse{\equal{#1}{}}{\newtheorem{h#2}[hthm]{#4}}{\newtheorem{h#2}{#4}[#1]}
\expandafter\newcommand\csname r#2\endcsname[1]{#3~\ref{#2:##1}}
\expandafter\newcommand\csname R#2\endcsname[1]{#4~\ref{#2:##1}}
\newenvironmentx{#2}[2][1=,2=]{
\ifthenelse{\equal{##2}{}}{\begin{h#2}}{\begin{h#2}[##2]}
\ifthenelse{\equal{##1}{}}{}{\label{#2:##1}}
}{\end{h#2}}
}

\newref[section]{thm}{theorem}{Theorem}
\newref{lem}{lemma}{Lemma}
\newref{prop}{proposition}{Proposition}
\newref{cor}{corollary}{Corollary}

\theoremstyle{definition}
\newref{defn}{definition}{Definition}
\newref{example}{example}{Example}

\theoremstyle{remark}
\newref{remark}{remark}{Remark}

\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand{\D}{\mathsf{D}}
\newcommand{\bbG}{\mathbb{G}}
\newcommand{\Set}{\cat{Set}}
\newcommand{\PSh}[1]{\Set^{#1^{op}}}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\glob}{\PSh{\bbG}}
\newcommand{\ocat}{\omega \cat{Cat}}
\newcommand{\Dn}[1][n]{\mathrm{D}^{#1}}
\newcommand{\dDn}[1][n]{\mathrm{\partial D}^{#1}}

\newcommand{\pb}[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}
\newcommand{\po}[1][dr]{\save*!/#1+1.2pc/#1:(1,-1)@^{|-}\restore}

\numberwithin{table}{section}

\begin{document}

\title{Homotopy Type Theory}

\author{Valery Isaev}

\begin{abstract}
In this paper, we give a description of an evaluation algorithm for homotopy type theory.
\end{abstract}

\maketitle

\section{Introduction}

\section{Cellular sets}

In this section, we will recall the definition of cellular sets.

\begin{defn}
A \emph{globular set} is a presheaf on the category $\bbG$, whose objects are natural numbers and morphisms are generated from
$\sigma_n,\tau_n : n \to n + 1$ subject to the equations
$\sigma_{n+1} \circ \sigma_n = \tau_{n+1} \circ \sigma_n$, $\sigma_{n+1} \circ \tau_n = \tau_{n+1} \circ \tau_n$.
A morphism of globular sets is a morphism of presheaves.
\end{defn}

Explicitly, a globular set is a sequence of sets $X_n$ together with maps $s_k,t_k : X_n \to X_k$ for each $k < n$ subject to equations.
Elements of $X_n$ are called $n$-cells. Given $n$-cell $x$, cells $s_k(x)$ and $t_k(x)$
are called the ($k$-dimensional) source and the target of $x$ respectively.
A pair of $n$-cells $x$ and $y$ are \emph{parallel} if $s_k(x) = s_k(y)$ and $t_k(x) = t_k(y)$ for each $k < n$.
The expression $x : a \to b$ stands for the following:
there is $n \in \nats$ such that $a$ and $b$ are (necessarily parallel) $n$-cells,
$x$ is an $(n+1)$-cell, $s_n(x) = a$, and $t_n(x) = b$.

For each $n \in \nats$, the globular set $\bbG(-,n)$ is denoted by $\Dn$.
The globular sets $\dDn$ together with the maps $\dDn \to \Dn$ are defined by induction on $n$.
$\dDn[0]$ is the initial object, and $\dDn[0] \to \Dn[0]$ is the unique morphism.
$\dDn[n+1]$ is the pushout $\Dn \amalg_{\dDn} \Dn$, and $\dDn[n+1] \to \Dn[n+1]$
is induced by the maps $(\sigma_n \circ -)$ and $(\tau_n \circ -)$.

\begin{defn}
A \emph{strict $\omega$-category} is a globular set equipped with the following operations.
\begin{itemize}
\item For each $n$-cell $x$, an $(n+1)$-cell $id_x : x \to x$ called the \emph{identity} on $x$.
\item For each $n,k \in \nats$ and for each pair of $n$-cells $x$,$y$ such that
$t_k(x) = s_k(y)$ (in this case we say $x$ and $y$ are \emph{$k$-composable}),
an $n$-cell $y *_k x$ called \emph{k-composite} of $x$ and $y$.
\end{itemize}
We often regard an $n$-cell $x$ as a cell of a dimension higher than $n$ iteratively applying $id$ to $x$.

The operations above must satisfy the following properties.
\begin{itemize}
\item If $x : a \to b$, $y : b \to c$ is a pair of $n$-composable $(n+1)$-cells, then $y *_n x : a \to c$.
\item If $k < n$ and $x : a \to b$, $y : c \to d$ is a pair of $k$-composable $(n+1)$-cells, then $y *_k x : c *_k a \to d *_k b$.
\item If $x,y,z$ are $n$-cells, then $(z *_k y) *_k x = z *_k (y *_k x)$, whenever it makes sense.
\item If $k < n$ and $x$ is an $n$-cell, then $t_k(x) *_k x = x = x *_k s_k(x)$.
\item If $k < n$ and $x$,$y$ is a pair of $k$-composable $n$-cells, then $id_y *_k id_x = id_{y *_k x}$.
\item If $x$,$y$,$z$,$u$ are $n$-cells and $m < k < n$, then $(x *_k y) *_m (z *_k u) = (x *_m z) *_k (y *_m u)$, whenever it makes sense.
\end{itemize}

An $\omega$-functor between a pair of $\omega$-categories is a morphism of
the underlying globular sets commuting with compositions and identities.
The category $\ocat$ has $\omega$-categories as objects and $\omega$-functors as morphisms.
\end{defn}

The forgetful functor $U : \ocat \to \glob$ has a left adjoint $F : \glob \to \ocat$.
Let us denote by $(T : \glob \to \glob, \eta_X : X \to T(X), \mu_X : T T(X) \to T(X))$ the monad $U \circ F$,
and by $\dDn_T$ and $\Dn_T$ the $\omega$-categories $T(\dDn)$ and $T(\Dn)$.

An \emph{$n$-dimensional pasting diagram} is defined by induction on $n$.
There is exactly one $0$-dimensional pasting diagram, which is denoted by $\diamond$.
An $(n+1)$-dimensional pasting diagram is a finite sequence of $n$-dimensional pasting diagrams.

With each $n$-dimensional pasting diagram $\pi$ we associate an $n$-dimensional globular set $\widehat{\pi}$.
If $\pi$ is the unique $0$-dimensional pasting diagram, then $\widehat{\pi}$ is the terminal $0$-dimensional globular set.
If $\pi = (\pi^1, \ldots \pi^k)$, then let $\widehat{\pi}_0 = \{0, 1, \ldots k\}$
and $\widehat{\pi}_{m+1} = \coprod \limits_{i = 1}^k \widehat{\pi^i}_m$.
For each $k > 0$, the source and the target are defined in the evident way,
and for each $x \in \widehat{\pi^i}$, we define $s_0(x) = i - 1$ and $t_0(x) = i$.

\begin{defn}
The category $\Theta$ has pasting diagrams as objects, and the set of morphisms between $\pi_1$ and $\pi_2$
is the set of morphisms between strict $\omega$-categories $T(\widehat{\pi_1})$ and $T(\widehat{\pi_2})$.
That is, $\Theta$ is a full subcategory of $\ocat$.
A cellular set is a presheaf on $\Theta$, a morphism of cellular sets is a morphism of presheaves.
\end{defn}

\section{Syntax and Inference Rules}

First, let us define the sets of raw terms and contexts:
\[ Tm ::= v_i\ |\ U_\alpha\ |\ \Pi A B\ |\ \lambda b\ |\ b\,a\ |\ \Sigma A B\ |\ a , b\ |\ proj_1\,p\ |\ proj_2\,p\ |\ (a = a'\,|\,A)\ |\ idp\,a, \]
\[ Ctx ::= \epsilon\ |\ \Gamma, A, \]
where $i \in \Z$, $\alpha \in \nats$, $\Gamma \in Ctx$, and $a, a', b, p, A, B \in Tm$.
Similarly to \cite{norm}, we use de Bruijn's representation of lambda terms.

The meaning of each term should be clear from the inference rules listed in table \ref{table:inf-rules}.
Note that we do not use reduction rules, instead we define terms to be computationally equal if their interpretations coincide.
Thus inference rules depend on the evaluation function $\llbracket - \rrbracket$ that will be defined in section \ref{sec:eval}.

\centerAlignProof

\begin{table}
\begin{center}
\AxiomC{}
\UnaryInfC{$\epsilon \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\UnaryInfC{$\Gamma, A \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $0 \leq i < | \Gamma |$}
\UnaryInfC{$\Gamma \vdash v_i : \Gamma(i)$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $\alpha < \beta$}
\UnaryInfC{$\Gamma \vdash U_\alpha : U_\beta$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\BinaryInfC{$\Gamma \vdash \Pi A B : U_{max(\alpha,\beta)}$}
\DisplayProof
\quad
\AxiomC{$\Gamma, A \vdash b : B$}
\UnaryInfC{$\Gamma \vdash \lambda b : \Pi A B$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash b : \Pi A B$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash b\,a : B[a]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\BinaryInfC{$\Gamma \vdash \Sigma A B : U_{max(\alpha,\beta)}$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B[a]$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\TrinaryInfC{$\Gamma \vdash a, b : \Sigma A B$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : \Sigma A B$}
\UnaryInfC{$\Gamma \vdash proj_1\,p : \Sigma A B$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash p : \Sigma A B$}
\UnaryInfC{$\Gamma \vdash proj_2\,p : B[proj_1\,p]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : A = B\,|\,idp\,U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B$}
\TrinaryInfC{$\Gamma \vdash a = b\,|\,p : U_\alpha$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash a : A$}
\UnaryInfC{$\Gamma \vdash idp\,a : a = a\,|\,idp\,A$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B : U_\beta$}
\RightLabel{, $\llbracket A \rrbracket^{\rho_\Gamma}_0 = \llbracket B \rrbracket^{\rho_\Gamma}_0$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{center}

\bigskip
\caption{Inference rules.}
\label{table:inf-rules}
\end{table}

\section{Evaluation}
\label{sec:eval}

We work in a suitable category of domains (see, for example, \cite{domains} for more information on the topic).
Let $TM$ be the set of functions $\nats \to Tm$, $Ob(\bbG)$ the set of objects,
and $Hom(\bbG)$ the set of morphisms of the category $\bbG$, thus $Ob(\bbG)$ is simply the set of natural numbers.
Let $(\D,\sqsubseteq)$ be a domain satisfying the following equation:
\[ \D = [Hom(\bbG)_\bot \times \D \to \D] \oplus \D \times \D \oplus (\omega + 1)_\bot \oplus \D \]
\[ \oplus [\nats_\bot \to \D \times \D] \times TM_\bot \oplus Ob(\bbG)_\bot \times \D \times \D \times \D \]
% \oplus \D \times \D \times \D \]
\[ \oplus Ob(\bbG)_\bot \times \D \times [Hom(\bbG)_\bot \times \D \to \D] \]
\[ \oplus Ob(\bbG)_\bot \times \D \times [Hom(\bbG)_\bot \times \D \to \D] \]

Here, $\omega + 1$ denotes the set $\nats \cup \{ \omega \}$.
The meaning of the components in this equaltion should be clear from the names of the constructors:
\begin{itemize}
\item[] $\mathsf{Lam} : [Hom(\bbG)_\bot \times \D \to \D] \to \D$
\item[] $\mathsf{Pair} : \D \times \D \to \D$
\item[] $\mathsf{U} : (\omega + 1)_\bot \to \D$
\item[] $\mathsf{Idp} : \D \to \D$
\item[] $\mathsf{Ne} : [\nats_\bot \to \D \times \D] \times TM_\bot \to \D$
\item[] $\mathsf{Id} : Ob(\bbG)_\bot \times \D \times \D \times \D \to \D$
% \item[] $\mathsf{Path} : \D \times \D \times \D \to \D$
\item[] $\mathsf{Pi} : Ob(\bbG)_\bot \times \D \times [Hom(\bbG)_\bot \times \D \to \D] \to \D$
\item[] $\mathsf{Sigma} : Ob(\bbG)_\bot \times \D \times [Hom(\bbG)_\bot \times \D \to \D] \to \D$
\end{itemize}

Let $Env$ be the domain $[\nats_\bot \to \D]$.
If $\rho \in Env$ and $x \in \D$, then we define $\rho[x] \in Env$ to be the function defined by the following rules: $\rho[x](0) = x$ and $\rho[x](i+1) = \rho(i)$.
Now, we define the evaluation function:
\begin{itemize}
\item[] $\llbracket - \rrbracket : Tm_\bot \times Env \times Ob(\bbG)_\bot \to \D$
\item[] $\llbracket v_i \rrbracket^\rho_n = \rho(i)$, if $i \geq 0$, and $\bot$, otherwise.
\item[] $\llbracket U_\alpha \rrbracket^\rho_n = \mathsf{U}(\alpha)$, if $\alpha \in \nats$, and $\bot$, otherwise.
\item[] $\llbracket \Pi A B \rrbracket^\rho_n = \mathsf{Pi}(n, \llbracket A \rrbracket^\rho_n, (m, a) \mapsto \llbracket B \rrbracket^{(\mathsf{action}(m,-) \circ \rho)[a]}_{dom(m)})$
\item[] $\llbracket \Sigma A B \rrbracket^\rho_n = \mathsf{Sigma}(n, \llbracket A \rrbracket^\rho_n, (m, a) \mapsto \llbracket B \rrbracket^{(\mathsf{action}(m,-) \circ \rho)[a]}_{dom(m)})$
\item[] $\llbracket a = a' | A \rrbracket^\rho_n = \mathsf{Id}(n, \llbracket A \rrbracket^\rho_n, \llbracket a \rrbracket^\rho_n, \llbracket a' \rrbracket^\rho_n)$
\item[] $\llbracket \lambda b \rrbracket^\rho_n = \mathsf{Lam}((m, a) \mapsto \llbracket b \rrbracket^{(\mathsf{action}(m,-) \circ \rho)[a]}_{dom(m)})$
\item[] $\llbracket b\,a \rrbracket^\rho_n = \mathsf{app}(n, \llbracket b \rrbracket^\rho_n, \llbracket a \rrbracket^\rho_n)$
\item[] $\llbracket a, b \rrbracket^\rho_n = \mathsf{Pair}(\llbracket a \rrbracket^\rho_n, \llbracket b \rrbracket^\rho_n)$
\item[] $\llbracket proj_1\,p \rrbracket^\rho_n = \mathsf{proj_1}(\llbracket p \rrbracket^\rho_n)$
\item[] $\llbracket proj_2\,p \rrbracket^\rho_n = \mathsf{proj_2}(\llbracket p \rrbracket^\rho_n)$
\item[] $\llbracket idp\,a \rrbracket^\rho_n = \mathsf{action}(\delta_n, \llbracket a \rrbracket^\rho_n)$
\end{itemize}

Functions $\mathsf{app}$, $\mathsf{proj_1}$, $\mathsf{proj_2}$, $\mathsf{action}$, $\mathsf{IdOver}$, and $\mathsf{idp}$ are defined as follows:
\begin{itemize}
\item[] $\mathsf{app} : Ob(\bbG)_\bot \times \D \times \D \to \D$
\item[] $\mathsf{app}(n,\mathsf{Lam}(f),a) = f(id_n,a)$
\item[] $\mathsf{app}(n,e,a) = \bot$, otherwise
\item[]
\item[] $\mathsf{proj_1} : \D \to \D$
\item[] $\mathsf{proj_1}(\mathsf{Pair}(a,b)) = a$
\item[] $\mathsf{proj_1}(x) = \bot$, otherwise
\item[]
\item[] $\mathsf{proj_2} : \D \to \D$
\item[] $\mathsf{proj_2}(\mathsf{Pair}(a,b)) = b$
\item[] $\mathsf{proj_2}(x) = \bot$, otherwise
\item[]
\item[] $\mathsf{action} : Hom(\bbG)_\bot \times \D \to \D$
\item[] $\mathsf{action}(m, \mathsf{Lam}(f)) = \mathsf{Lam}((m',x) \mapsto f(m \circ m', x))$
\item[] $\mathsf{action}(m, \mathsf{Pair}(a, b)) = \mathsf{Pair}(\mathsf{action}(m, a), \mathsf{action}(m, b))$
\item[] $\mathsf{action}(m, \mathsf{U}(\alpha)) = \mathsf{U}(\alpha)$
\item[] $\mathsf{action}(m, \mathsf{Id}(n, A, a, a')) = \mathsf{Id}(dom(m), \mathsf{action}(m, A), \mathsf{action}(m, a), \mathsf{action}(m, a'))$
\item[] $\mathsf{action}(m, \mathsf{Pi}(n, A, B)) = \mathsf{Pi}(dom(m), \mathsf{action}(m, A), (m', x) \mapsto B(m \circ m', x))$
\item[] $\mathsf{action}(m, \mathsf{Sigma}(n, A, B)) = \mathsf{Sigma}(dom(m), \mathsf{action}(m, A), (m', x) \mapsto B(m \circ m', x))$
% \item[] $\mathsf{action}(\delta_n, \mathsf{Path}(l, r, a)) = TODO$
\item[] $\mathsf{action}(\delta_n, e) = \mathsf{Idp}(e)$
\item[]
\item[] $\mathsf{comp} : Ob(\bbG)_\bot \times \D \times \D \to \D$
\item[] $\mathsf{comp}(n, \mathsf{Idp}(d), \mathsf{Idp}(e)) = \mathsf{Idp}(\mathsf{comp}(n - 1, d, e))$, if $n > 0$
\item[] $\mathsf{comp}(n, d, e) = TODO$
\end{itemize}

\begin{comment}
\item[] $\mathsf{IdOver} : Ob(\bbG)_\bot \times \D \times \D \times \D \to \D$
\item[] $\mathsf{IdOver}(n, \mathsf{Sigma}(n', A, B), p, p') =$ \\
    \indent $\mathsf{Sigma}(n, \mathsf{IdOver}(n, A, \mathsf{proj_1}(p), \mathsf{proj_1}(p')), (m,a) \mapsto$ \\
    \indent $\mathsf{IdOver}(dom(m), B(m,a), \mathsf{action}(m, \mathsf{proj_2}(p)), \mathsf{action}(m, \mathsf{proj_2}(p'))))$
\item[] $\mathsf{IdOver}(n, \mathsf{Pi}(n', A, B), f, f') = \mathsf{Pi}(n, \mathsf{action}(\sigma_0\ \circ\ !_n, A), (m,a) \mapsto$ \\
    \indent $\mathsf{Pi}(dom(m), \mathsf{action}(\tau_0\ \circ\ !_n \circ m, A), (m',a') \mapsto$ \\
    \indent $\mathsf{Pi}(dom(m'), \mathsf{IdOver}(dom(m'), \mathsf{action}(m \circ m', A), \mathsf{action}(m', a), a'), (m'',p) \mapsto$ \\
    \indent $\mathsf{IdOver}(dom(m''), \mathsf{app}(dom(m''), \mathsf{action}(m \circ m' \circ m'', B), p),$ \\
    \indent \indent $\mathsf{app}(dom(m''), \mathsf{action}(m \circ m' \circ m'', f), \mathsf{action}(m' \circ m'', a)),$ \\
    \indent \indent $\mathsf{app}(dom(m''), \mathsf{action}(m \circ m' \circ m'', f'), \mathsf{action}(m'', a'))))))$, \\
    \indent where $!_n : n \to 0$ is the unique morphism into $0$ in $\Theta$
\item[] $\mathsf{IdOver}(n, \mathsf{Id}(n', A, a, a'), p, p') =$ \\
    \indent $\mathsf{IdOver}(n, \mathsf{idp}(n, \mathsf{IdOver}(n, A, \mathsf{action}(\sigma_0\ \circ\ !_n, a), \mathsf{action}(\tau_0\ \circ\ !_n. a'))),$ \\
    \indent $\mathsf{comp}(n, p, a'), \mathsf{comp}(n, a, p'))$
\item[] $\mathsf{IdOver}(n, \mathsf{Idp}(A), a, a') = \mathsf{Id}(n, A, a, a')$
\item[] $\mathsf{IdOver}(n, \mathsf{U}(\alpha), a, a') = \mathsf{Id}(n, \mathsf{U}(\alpha), a, a')$
\item[] $\mathsf{IdOver}(n, \mathsf{Ne}(l, e), a, a') = \mathsf{Ne}(TODO)$
\item[] $\mathsf{IdOver}(n, A, a, a') = \bot$, otherwise

The rest of the functions we used in the definition of $\llbracket - \rrbracket$ will be defined later in this section.

If $A$ is a term, then let $P^{(n)} A$ denote a term defined as follows: $P^{(0)} A = A$ and
$P^{(n + 1)} A = \Sigma A (\Sigma (\Uparrow^1\hspace{-.5em} A) (P^{(n)}(v_1 = v_0\,|\,idp\,(\Uparrow^2\hspace{-.5em} A))))$.
If $A \in \D$, then let $\mathsf{P}^{(n)} A = \llbracket P^{(n)} v_0 \rrbracket^{[0 \mapsto A, n \mapsto \bot]}_0$.
For each $n \in \nats$, define $\mathsf{s}_n,\mathsf{t}_n,\mathsf{c}_n : \D \to \D$ as follows:
$\mathsf{c}_0(x) = x$, $\mathsf{c}_{n + 1} = \mathsf{c}_n \circ \mathsf{proj_2} \circ \mathsf{proj_2}$,
$\mathsf{s}_n = \mathsf{proj_1} \circ \mathsf{c}_n$, and $\mathsf{t}_n = \mathsf{proj_1} \circ \mathsf{proj_2} \circ \mathsf{c}_n$.
\end{comment}

Let $\mathscr{P}(\D)$ denote the set of subset of $\D$.
If $A \in \mathscr{P}(\D)$ and $B : \D \to \mathscr{P}(\D)$, then define $\mathcal{S}igma A B, \mathcal{P}i A B, \mathcal{N}\!e, \mathcal{I}d\,A \in \mathscr{P}(\D)$ as follows:
\[ \mathcal{S}igma A B = \{ e \in \D\,|\,\mathsf{proj_1}(e) \in A, \mathsf{proj_2}(e) \in B(\mathsf{proj_1}(e)) \}, \]
\[ \mathcal{P}i A B = \{ e \in \D\,|\,\mathsf{app}(0,e,d) \in B(d) \text{ for all } d \in A \}, \]
\[ \mathcal{N}\!e = \{ \mathsf{Ne(l,e)}\,|\,l : \nats_\bot \to \D \times \D, e \in TM \}, \]
\[ \mathcal{I}d\,A = \mathcal{N}\!e \cup \{ \mathsf{Idp}(d)\,|\,d \in A \}. \]

Now, for each $\alpha \leq \omega$, we define $\mathcal{U}_\alpha \in \mathscr{P}(\D)$ and a partial function $[ - ]_\alpha : \D \to \mathscr{P}(\D)$ by induction on $\alpha$.
The graph $G_\alpha \subseteq \D \times \mathscr{P}(\D)$ of $[ - ]_\alpha$ is defined inductively by the following rules:
\medskip
\begin{center}
\AxiomC{$(a, A) \in G_\alpha$}
\AxiomC{$(b(id_0, d), B(d)) \in G_\alpha \text{ for all } d \in A$}
\BinaryInfC{$(\mathsf{Sigma}(0, a, b), \mathcal{S}igma A B) \in G_\alpha$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$(a, A) \in G_\alpha$}
\AxiomC{$(b(id_0, d), B(d)) \in G_\alpha \text{ for all } d \in A$}
\BinaryInfC{$(\mathsf{Pi}(0, a, b), \mathcal{P}i A B) \in G_\alpha$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{}
\UnaryInfC{$(\mathsf{Ne}(l, e), \mathcal{N}\!e) \in G_\alpha$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{, $\beta < \alpha$}
\UnaryInfC{$(\mathsf{U}(\beta), \mathcal{U}_\beta) \in G_\alpha$}
\DisplayProof
\end{center}
\medskip

\begin{comment}
\begin{center}
\AxiomC{$(\mathsf{Sigma}(0, \mathsf{Id}(0, A, \bot, \bot), (m,a) \mapsto \mathsf{Id}(dom(m), B(m, a), \bot, \bot)), X) \in G_\alpha$}
\UnaryInfC{$(\mathsf{Id}(0, \mathsf{Sigma}(1, A, B), x, y), X) \in G_\alpha$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$(\mathsf{Pi}(0, \mathsf{Id}(0, A, \bot, \bot), (m,a) \mapsto \mathsf{Id}(dom(m), B(m, a), \bot, \bot)), X) \in G_\alpha$}
\UnaryInfC{$(\mathsf{Id}(0, \mathsf{Pi}(1, A, B), x, y), X) \in G_\alpha$}
\DisplayProof
\end{center}
\medskip
\end{comment}

\begin{center}
\AxiomC{$(\mathsf{IdOver}(0, a, x, y), A) \in G_\alpha$}
\UnaryInfC{$(\mathsf{Id}(0, a, x, y), A) \in G_\alpha$}
\DisplayProof
\quad
\AxiomC{$(a, A) \in G_\alpha$}
\UnaryInfC{$(\mathsf{Id}(0, \mathsf{Idp}(a), x, y), \mathcal{I}d\,A) \in G_\alpha$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{}
\UnaryInfC{$(\mathsf{Id}(0, \mathsf{U}(\alpha), x, y), \mathcal{IU}) \in G_\alpha$}
\DisplayProof
\end{center}
\medskip

We inductively define $\mathcal{U}_\alpha \in \mathscr{P}(\D)$ by the following rules:
\medskip
\begin{center}
\AxiomC{$a \in \mathcal{U}_\alpha$}
\AxiomC{$b(id_0, d) \in \mathcal{U}_\alpha \text{ for all } d \in [a]_\alpha$}
\BinaryInfC{$\mathsf{Sigma}(0, a, b) \in \mathcal{U}_\alpha$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$a \in \mathcal{U}_\alpha$}
\AxiomC{$b(id_0, d) \in \mathcal{U}_\alpha \text{ for all } d \in [a]_\alpha$}
\BinaryInfC{$\mathsf{Pi}(0, a, b) \in \mathcal{U}_\alpha$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{}
\UnaryInfC{$\mathsf{Ne}(l,e) \in \mathcal{U}_\alpha$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{, $\beta < \alpha$}
\UnaryInfC{$\mathsf{U}(\beta) \in \mathcal{U}_\alpha$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\mathsf{Id}(0, a, x, y) \in \mathcal{U}_\alpha$}
\DisplayProof
\quad
\end{center}
We write simply $\mathcal{U}$ and $[ - ]$ for $\mathcal{U}_\omega$ and $[ - ]_\omega$.

\begin{lem}
For each $\alpha \leq \omega$, the graph $G_\alpha$ defines a partial function, that is $(a, A), (a, A') \in G_\alpha$ implies $A = A'$.
For each $\alpha \leq \omega$, the partial function $[ - ]_\alpha : \D \to \mathscr{P}(\D)$ is defined on $\mathcal{U}_\alpha \subseteq \D$.
\end{lem}
\begin{proof}
The first statement is proved by induction on generation of $G_\alpha$ and the second by induction on generation of $\mathcal{U}_\alpha$.
\end{proof}

For each context $\Gamma$ (that is, finite sequence of terms), we define its interpretation $[ \Gamma ] \subseteq Env$ as follows:
$\rho \in \Gamma$ if and only if $\rho(i) \in [\llbracket \Gamma(i) \rrbracket^\rho_0]$ for each $0 \leq i < |\Gamma|$.
We define a predicate on contexts $\Gamma \models$ inductively as follows:

\centerAlignProof

\medskip
\begin{center}
\AxiomC{}
\UnaryInfC{$\epsilon \models$}
\DisplayProof
\quad
\AxiomC{$\Gamma \models$}
\AxiomC{$\llbracket A \rrbracket^\rho_0 \in \mathcal{U} \text{ for all } \rho \in [\Gamma]$}
\BinaryInfC{$\Gamma, A \models$}
\DisplayProof
\end{center}
\medskip

We write $\Gamma \models a : A$ if and only if $\Gamma \models$,
$\forall \rho \in [\Gamma], \llbracket A \rrbracket^\rho_0 \in \mathcal{U}$,
and $\forall \rho \in [\Gamma], \llbracket a \rrbracket^\rho_0 \in [\llbracket A \rrbracket^\rho_0]$.

\begin{prop}
If $\Gamma \vdash$, then $\Gamma \models$.
If $\Gamma \vdash a : A$, then $\Gamma \models a : A$.
\end{prop}
\begin{proof}
By induction on the derivation.
Most of the cases are straightforward, let us prove some of them:
\begin{itemize}
\item Case
\AxiomC{$\Gamma, A \vdash b : B$}
\UnaryInfC{$\Gamma \vdash \lambda b : \Pi A B$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash b : \Pi A B$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash b\,a : B[a]$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash p : A = B\,|\,idp\,U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B$}
\TrinaryInfC{$\Gamma \vdash a = b\,|\,p : U_\alpha$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash a : A$}
\UnaryInfC{$\Gamma \vdash idp\,a : a = a\,|\,idp\,A$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B : U_\beta$}
\RightLabel{, $\llbracket A \rrbracket^{\rho_\Gamma}_0 = \llbracket B \rrbracket^{\rho_\Gamma}_0$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{itemize}
\end{proof}

Now, let us show how to reify elements of $\D$ into terms.
\begin{itemize}
\item[] $\mathsf{reify} : \nats_\bot \times \D \times \D \to Tm_\bot$
\item[] $\mathsf{reify}(i, \mathsf{Lam}(f), \mathsf{Pi}(0, A, B)) = \lambda\,\mathsf{reify}(i + 1, f(id_0, x), B(id_0, x))$, \\
        \indent where $x = \mathsf{reflect}(l \mapsto v_{l - i - 1}, A)$
\item[] $\mathsf{reify}(i, \mathsf{Pair}(a, b), \mathsf{Sigma}(0, A, B)) = \mathsf{reify}(i, a, A), \mathsf{reify}(i, b, B(id_0, a))$
\item[] $\mathsf{reify}(i, \mathsf{U}(\alpha), \mathsf{U}(\beta)) = U_\alpha$, if $\alpha < \beta$
\item[] $\mathsf{reify}(i, \mathsf{Idp}(a), \mathsf{Id}(0, t, a', a'')) = idp\,\mathsf{reify}(i, a, t)$
\item[] $\mathsf{reify}(i, \mathsf{Ne}(l, e), t) = e(i)$
\item[] $\mathsf{reify}(i, \mathsf{Id}(0, A, a, a'), \mathsf{U}(\alpha)) = (\mathsf{reify}(i, a, A) = \mathsf{reify}(i, a', A)\,|\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))$)
\item[] $\mathsf{reify}(i, \mathsf{Pi}(0, A, B), \mathsf{U}(\alpha)) =$
        $\Pi\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))\,\mathsf{reify}(i + 1, B(id_0, x), \mathsf{U}(\alpha))$, \\
        \indent where $x = \mathsf{reflect}(l \mapsto v_{l - i - 1}, A)$
\item[] $\mathsf{reify}(i, \mathsf{Sigma}(0, A, B), \mathsf{U}(\alpha)) = $
        $\Sigma\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))\,\mathsf{reify}(i + 1, B(id_0, x), \mathsf{U}(\alpha))$, \\
        \indent where $x = \mathsf{reflect}(l \mapsto v_{l - i - 1}, A)$
\item[] $\mathsf{reify}(i, e, t) = \bot$, otherwise.
\item[]
\item[] $\mathsf{reflect} : TM_\bot \times \D \to \D$
\item[] $\mathsf{reflect}(e,\mathsf{Pi}(0, A, B)) = \mathsf{Lam}((m, a) \mapsto \mathsf{reflect}(l \mapsto e(l)\,\mathsf{reify}(0, a, A), B(id_0, a)))$
\item[] $\mathsf{reflect}(e,\mathsf{Sigma}(0, A, B)) = \mathsf{Pair}(a, \mathsf{reflect}(l \mapsto proj_2\,e(l), B(id_0, a)))$, \\
        \indent where $a = \mathsf{reflect}(l \mapsto proj_1\,e(l), A)$
\item[] $\mathsf{reflect}(e,t) = Ne(n \mapsto \bot, e)$, otherwise
\end{itemize}

\bibliographystyle{amsplain}
\bibliography{ref}

\end{document}
