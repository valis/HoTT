\documentclass{amsart}

\usepackage{amssymb}
\usepackage[all]{xy}
\usepackage{verbatim}
\usepackage{ifthen}
\usepackage{xargs}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage{mathrsfs}

\providecommand\WarningsAreErrors{false}
\ifthenelse{\equal{\WarningsAreErrors}{true}}{\renewcommand{\GenericWarning}[2]{\GenericError{#1}{#2}{}{This warning has been turned into a fatal error.}}}{}

\newcommand{\newref}[4][]{
\ifthenelse{\equal{#1}{}}{\newtheorem{h#2}[hthm]{#4}}{\newtheorem{h#2}{#4}[#1]}
\expandafter\newcommand\csname r#2\endcsname[1]{#3~\ref{#2:##1}}
\expandafter\newcommand\csname R#2\endcsname[1]{#4~\ref{#2:##1}}
\newenvironmentx{#2}[2][1=,2=]{
\ifthenelse{\equal{##2}{}}{\begin{h#2}}{\begin{h#2}[##2]}
\ifthenelse{\equal{##1}{}}{}{\label{#2:##1}}
}{\end{h#2}}
}

\newref[section]{thm}{theorem}{Theorem}
\newref{lem}{lemma}{Lemma}
\newref{prop}{proposition}{Proposition}
\newref{cor}{corollary}{Corollary}

\theoremstyle{definition}
\newref{defn}{definition}{Definition}
\newref{example}{example}{Example}

\theoremstyle{remark}
\newref{remark}{remark}{Remark}

\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand{\D}{\mathsf{D}}
\newcommand{\bbG}{\mathbb{G}}
\newcommand{\Set}{\cat{Set}}
\newcommand{\PSh}[1]{\Set^{#1^{op}}}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\glob}{\PSh{\bbG}}
\newcommand{\ocat}{\omega \cat{Cat}}
\newcommand{\Dn}[1][n]{\mathrm{D}^{#1}}
\newcommand{\dDn}[1][n]{\mathrm{\partial D}^{#1}}

\newcommand{\pb}[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}
\newcommand{\po}[1][dr]{\save*!/#1+1.2pc/#1:(1,-1)@^{|-}\restore}

\numberwithin{table}{section}

\begin{document}

\title{Homotopy Type Theory}

\author{Valery Isaev}

\begin{abstract}
In this paper, we give a description of an evaluation algorithm for homotopy type theory.
\end{abstract}

\maketitle

\section{Introduction}

\section{Cubical sets}

In this section, we will recall the definition of cubical sets.
We use cubical sets with connections, but call them simply cubical sets.

Let $\Box$ be the following category. Its objects are natural numbers, and morphisms are generated from
\[ \partial^\alpha_i : n \to n + 1, \]
\[ \epsilon_i : n + 1 \to n, \]
\[ \Gamma^\alpha_j : n + 1 \to n, \]
for each $n \in \nats$, $0 \leq i \leq n$, $0 \leq j < n$, and $\alpha = \pm$.
These maps satisfy the following equations:
\[ \partial^\alpha_j \partial^\beta_i = \partial^\beta_i \partial^\alpha_{j-1} \text{ if $i < j$}, \]
\[ \epsilon_j \epsilon_i = \epsilon_i \epsilon_{j+1} \text{ if $i \leq j$}, \]
\[ \Gamma^\alpha_j \Gamma^\beta_i = \Gamma^\beta_i \Gamma^\alpha_{j+1} \text{ if $i < j$}, \]
\[ \Gamma^\alpha_i \Gamma^\alpha_i = \Gamma^\alpha_i \Gamma^\alpha_{i+1}, \]
\[ \epsilon_j \partial^\alpha_i = \left\{ \begin{array}{l l}
            \partial^\alpha_i \epsilon_{j-1} & \text{if $i < j$} \\
            id                               & \text{if $i = j$} \\
            \partial^\alpha_{i-1} \epsilon_j & \text{if $i > j$},
    \end{array} \right. \]
\[ \epsilon_j \Gamma^\alpha_i = \left\{ \begin{array}{l l}
            \Gamma^\alpha_i \epsilon_{j+1} & \text{if $i < j$} \\
            \epsilon_j \epsilon_j         & \text{if $i = j$} \\
            \Gamma^\alpha_{i-1} \epsilon_j & \text{if $i > j$},
    \end{array} \right. \]
\[ \Gamma^\beta_j \partial^\alpha_i = \left\{ \begin{array}{l l}
            \partial^\alpha_i \Gamma^\beta_{j-1} & \text{if $i < j$} \\
            id                                   & \text{if $j \leq i \leq j + 1$ and $\alpha = \beta$} \\
            \partial^\alpha_j \epsilon_j         & \text{if $j \leq i \leq j + 1$ and $\alpha = -\beta$} \\
            \partial^\alpha_{i-1} \Gamma^\beta_j & \text{if $i > j + 1$}.
    \end{array} \right. \]

A map in the category $\Box$ is \emph{injective} (resp., \emph{surjective}) if it is a composition of maps of the form $\partial^\alpha_i$ (resp., $\epsilon_i$ and $\Gamma^\alpha_i$).
A cubical set is a presheaf on the category $\Box$.

\section{Cubical syntax}

In this section, we will define cubical terms and inference rules for them.
For now, we define only $\Pi$ and $\Sigma$ types.
Later, we will extend the syntax by adding path types, (univalent) universes, and (higher) inductive types.

Let $Vars$ be a countably infinite set of variables.
Then we define the sets of raw terms and contexts as follows:
\[ Tm ::= \alpha^* x\ |\ \Pi (x : A) B\ |\ \lambda x. b\ |\ f\ a\ |\ \Sigma (x : A) B\ |\ a , b\ |\ proj_1\ p\ |\ proj_2\ p, \]
\[ Ctx ::= \varnothing\ |\ \Gamma, x : A, \]
where $x \in Vars$, $\Gamma \in Ctx$, $a, b, f, p, A, B \in Tm$, and $\alpha$ is a map in the category $\Box$.

For each $\alpha : k \to n$ and term $t$, we define a term $\alpha^* t$ as follows:
\begin{itemize}
\item[] $\alpha^* (\beta^* x) = \left\{\begin{array}{l l}
            (\beta \alpha)^* x  & \text{if $x \in FV(t)$} \\
            \beta^* x           & \text{otherwise,}
        \end{array} \right.$
\item[] $\alpha^* (\Pi (x : A) B) = \Pi (x : \alpha^* A) (\alpha^* B)$
\item[] $\alpha^* (\lambda x. b) = \lambda x. \alpha^* b$
\item[] $\alpha^* (f\ a) = \alpha^* f\ \alpha^* a$
\item[] $\alpha^* (\Sigma (x : A) B) = \Sigma (x : \alpha^* A) (\alpha^* B)$
\item[] $\alpha^* (a , b) = \alpha^* a , \alpha^* b$
\item[] $\alpha^* (proj_1\ p) = proj_1 (\alpha^* p)$
\item[] $\alpha^* (proj_2\ p) = proj_2 (\alpha^* p)$
\end{itemize}

\centerAlignProof

\begin{table}
\begin{center}
\AxiomC{}
\UnaryInfC{$\varnothing \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash A : Type_n$}
\RightLabel{, $x \notin \Gamma$}
\UnaryInfC{$\Gamma, x : A \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash A : Type_n$}
\RightLabel{, $x : A \in \Gamma, \alpha : k \to n$}
\UnaryInfC{$\Gamma \vdash \alpha^* x : \alpha^* A$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash A : Type_n$}
\AxiomC{$\Gamma, x : A \vdash B : Type_n$}
\BinaryInfC{$\Gamma \vdash \Pi (x : A) B : Type_n$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash f : \Pi (x : A) B$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash f\ a : B[x := a]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\alpha^* \Gamma, x : \alpha^* A \vdash b : \alpha^* B$ for all injective $\alpha : k \to n$}
\AxiomC{$\Gamma \vdash A : Type_n$}
\BinaryInfC{$\Gamma \vdash \lambda x. b : \Pi (x : A) B$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash A : Type_n$}
\AxiomC{$\Gamma, x : A \vdash B : Type_n$}
\BinaryInfC{$\Gamma \vdash \Sigma (x : A) B : Type_n$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B[x := a]$}
\AxiomC{$\Gamma \vdash \Sigma (x : A) B : Type_n$}
\TrinaryInfC{$\Gamma \vdash a, b : \Sigma (x : A) B$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : \Sigma (x : A) B$}
\UnaryInfC{$\Gamma \vdash proj_1\ p : A$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash p : \Sigma (x : A) B$}
\UnaryInfC{$\Gamma \vdash proj_2\ p : B[x := proj_1\ p]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B : Type_n$}
\RightLabel{, $A =_c B$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{center}

\bigskip
\caption{Inference rules.}
\label{table:inf-rules}
\end{table}

\section{Evaluation}
\label{sec:eval}

We work in a suitable category of domains (see, for example, \cite{domains} for more information on the topic).
Let $TM$ be the set of functions $\nats \to Tm$, $Ob(\theta)$ the set of objects, and $Hom(\theta)$ the set of morphisms of the category $\theta$.
Let $(\D,\sqsubseteq)$ be a domain satisfying the following equation:
\[ \D = [Hom(\theta)_\bot \times \D \to \D] \oplus \D \times \D \oplus (\omega + 1)_\bot \oplus \D \times \D \times \mathsf{List}(\D \times \D) \times \D \]
\[ \oplus \D \times \D \times TM_\bot \times \nats_\bot \oplus \D \times \D \times \D \oplus \D \times \D \times \D \oplus \D \times \D \oplus \D \times \D, \]
where $\omega + 1$ denotes the set $\nats \cup \{ \omega \}$, and $\mathsf{List}(\D \times \D)$ is a domain of finite sequences of elements of $\D \times \D$.
We introduce the following names for the constructors:
\begin{itemize}
\item[] $\mathsf{Lam} : [Hom(\theta)_\bot \times \D \to \D] \to \D$
\item[] $\mathsf{Pair} : \D \times \D \to \D$
\item[] $\mathsf{U} : (\omega + 1)_\bot \to \D$
\item[] $\mathsf{Path} : \D \times \D \times \mathsf{List}(\D \times \D) \times \D \to \D$
\item[] $\mathsf{Ne} : \D \times \D \times TM_\bot \times \nats_\bot \to \D$
\item[] $\mathsf{Tri} : \D \times \D \times \D \to \D$
\item[] $\mathsf{Id} : \D \times \D \times \D \to \D$
\item[] $\mathsf{Pi} : \D \times \D \to \D$
\item[] $\mathsf{Sigma} : \D \times \D \to \D$
\end{itemize}

First, let us show how to reify elements of $\D$ into terms.
\begin{itemize}
\item[] $\mathsf{reify} : \nats_\bot \times \nats_\bot \times \D \times \D \to Tm_\bot$
\item[] $\mathsf{reify}(i, n, \mathsf{Lam}(f), \mathsf{Pi}(A, B)) = \lambda\,\mathsf{reify}(i + 1, n, f(id_n, x), \mathsf{app}(n, B, x))$, \\
        \indent where $x = \mathsf{reflect}(n, k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, n, \mathsf{Pair}(a, b), \mathsf{Sigma}(A, B)) = \mathsf{reify}(i, n, a, A), \mathsf{reify}(i, n, b, \mathsf{app}(0, B, a))$
\item[] $\mathsf{reify}(i, n, \mathsf{Path}(a, b, s, x), \mathsf{Id}(A, a', b')) = \mathsf{reify}(i, n + 1, x, A)$
\item[] $\mathsf{reify}(i, n, \mathsf{U}(\alpha), \mathsf{U}(\beta)) = U_\alpha$, if $\alpha < \beta$
\item[] $\mathsf{reify}(i, n, \mathsf{Ne}(s, e, c), t) = e(i)$
\item[] $\mathsf{reify}(i, n, \mathsf{Id}(A, a, a'), \mathsf{U}(\alpha)) =$ \\
        \indent $(\mathsf{reify}(i, n, a, A) = \mathsf{reify}(i, n, a', A)\,|\,\mathsf{reify}(i, n + 1, A, \mathsf{U}(\alpha))$)
\item[] $\mathsf{reify}(i, n, \mathsf{Pi}(A, B), \mathsf{U}(\alpha)) =$ \\
        \indent $\Pi\,\mathsf{reify}(i, n, A, \mathsf{U}(\alpha))\,\mathsf{reify}(i + 1, n, \mathsf{app}(n, B, x), \mathsf{U}(\alpha))$, \\
        \indent where $x = \mathsf{reflect}(n, k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, n, \mathsf{Sigma}(A, B), \mathsf{U}(\alpha)) = $ \\
        \indent $\Sigma\,\mathsf{reify}(i, n, A, \mathsf{U}(\alpha))\,\mathsf{reify}(i + 1, n, \mathsf{app}(n, B, x), \mathsf{U}(\alpha))$, \\
        \indent where $x = \mathsf{reflect}(n, k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, n, e, t) = \bot$, otherwise
\item[]
\item[] $\mathsf{reflect} : \nats_\bot \times TM_\bot \times \D \to \D$
\item[] $\mathsf{reflect}(n, e, \mathsf{Pi}(A, B)) = \mathsf{Lam}((m, a) \mapsto $ \\
        \indent $\mathsf{reflect}(dom(m), k \mapsto e(k)\ \mathsf{reify}(k, dom(m), a, A), \mathsf{app}(dom(m), B, a)))$
\item[] $\mathsf{reflect}(n, e, \mathsf{Sigma}(A, B)) = \mathsf{Pair}(a, \mathsf{reflect}(n, k \mapsto proj_2\ e(k), \mathsf{app}(n, B, a)))$, \\
        \indent where $a = \mathsf{reflect}(n, k \mapsto proj_1\ e(k), A)$
\item[] $\mathsf{reflect}(n, e, \mathsf{Id}(A, a, a')) = \mathsf{Path}(a, a', [\,], \mathsf{reflect}(n + 1, e, A))$
\item[] $\mathsf{reflect}(n, e, t) = Ne(i \mapsto \bot, e, 0)$, otherwise
\end{itemize}

If $\mathsf{X}$ is a domain, $\rho : \nats_\bot \to \mathsf{X}$, and $x \in \mathsf{X}$,
then let $\rho[x] : \nats_\bot \to \mathsf{X}$ be the function defined by the following rules: $\rho[x](0) = x$ and $\rho[x](i+1) = \rho(i)$.
Let $Env$ be the domain $[\nats_\bot \to \D]$.
Now, we define a part of the evaluation function, the rest of the cases will be defined later.
\begin{itemize}
\item[] $\llbracket - \rrbracket : Tm_\bot \times Env \times Ob(\theta)_\bot \to \D$
\item[] $\llbracket v_i \rrbracket^\rho_n = \rho(i)$, if $i \geq 0$, and $\bot$, otherwise.
\item[] $\llbracket U_\alpha \rrbracket^\rho_n = \mathsf{U}(\alpha)$
\item[] $\llbracket \lambda b \rrbracket^\rho_n = \mathsf{Lam}((m, a) \mapsto \llbracket b \rrbracket^{(i \mapsto m \cdot \rho(i))[a]}_{dom(m)})$
\item[] $\llbracket b\ a \rrbracket^\rho_n = \mathsf{app}(n, \llbracket b \rrbracket^\rho_n, \llbracket a \rrbracket^\rho_n)$
\item[] $\llbracket a, b \rrbracket^\rho_n = \mathsf{Pair}(\llbracket a \rrbracket^\rho_n, \llbracket b \rrbracket^\rho_n)$
\item[] $\llbracket proj_1\ p \rrbracket^\rho_n = \mathsf{proj_1}(\llbracket p \rrbracket^\rho_n)$
\item[] $\llbracket proj_2\ p \rrbracket^\rho_n = \mathsf{proj_2}(\llbracket p \rrbracket^\rho_n)$
\end{itemize}

\begin{comment}
\item[] $\llbracket \Pi A B \rrbracket^\rho_n = \mathsf{Pi}(\llbracket A \rrbracket^\rho_n, \mathsf{Lam}((m, a) \mapsto \llbracket B \rrbracket^{(i \mapsto m \cdot \rho(i))[a]}_{dom(m)}))$
\item[] $\llbracket \Sigma A B \rrbracket^\rho_n = \mathsf{Sigma}(\llbracket A \rrbracket^\rho_n, \mathsf{Lam}((m, a) \mapsto \llbracket B \rrbracket^{(i \mapsto m \cdot \rho(i))[a]}_{dom(m)}))$
\item[] $\llbracket a = a' | A \rrbracket^\rho_n = \mathsf{Id}(\mathsf{pdec}(\llbracket A \rrbracket^\rho_n), \llbracket a \rrbracket^\rho_n, \llbracket a' \rrbracket^\rho_n)$
\item[] $\llbracket idp\ a \rrbracket^\rho_n = \mathsf{Path}([(a_0, a'_0), \ldots (a_{n-1}, a'_{n-1})], \delta_n \cdot \llbracket a \rrbracket^\rho_n)$, \\
    \indent where $a_k  = \delta_k \cdot \llbracket a \rrbracket^{i \mapsto \sigma^k_n \cdot \rho(i)}_k$ and
                  $a'_k = \delta_k \cdot \llbracket a \rrbracket^{i \mapsto \tau^k_n \cdot \rho(i)}_k$
\item[] $\llbracket pmap\ b\ a \rrbracket^\rho_n = \mathsf{Path}([(x_0,x'_0), \ldots (x_{n-1},x'_{n-1}))], x)$, \\
    \indent where $x = \mathsf{app}(n + 1, \mathsf{pdec}(\llbracket b \rrbracket^\rho_n), \mathsf{pdec}(\llbracket a \rrbracket^\rho_n))$, \\
    \indent \indent $x_k = \mathsf{app}(k + 1, \mathsf{pdec}(\llbracket b \rrbracket^{i \mapsto \sigma^k_n \cdot \rho(i)}_k), \mathsf{pdec}(\llbracket a \rrbracket^{i \mapsto \sigma^k_n \cdot \rho(i)}_k))$, and \\
    \indent \indent $x'_k = \mathsf{app}(k + 1, \mathsf{pdec}(\llbracket b \rrbracket^{i \mapsto \tau^k_n \cdot \rho(i)}_k), \mathsf{pdec}(\llbracket a \rrbracket^{i \mapsto \tau^k_n \cdot \rho(i)}_k))$
\end{comment}

Functions $\mathsf{app}$, $\mathsf{proj_1}$, $\mathsf{proj_2}$, and $\cdot$ are defined as follows:
\begin{itemize}
\item[] $\mathsf{app} : Ob(\theta)_\bot \times \D \times \D \to \D$
\item[] $\mathsf{app}(n,\mathsf{Lam}(f),a) = f(id_n,a)$
\item[] $\mathsf{app}(n,e,a) = \bot$, otherwise
\item[]
\item[] $\mathsf{proj_1} : \D \to \D$
\item[] $\mathsf{proj_1}(\mathsf{Pair}(a,b)) = a$
\item[] $\mathsf{proj_1}(x) = \bot$, otherwise
\item[]
\item[] $\mathsf{proj_2} : \D \to \D$
\item[] $\mathsf{proj_2}(\mathsf{Pair}(a,b)) = b$
\item[] $\mathsf{proj_2}(x) = \bot$, otherwise
\item[]
\item[] $\mathsf{pdec} : \D \to \D$
\item[] $\mathsf{pdec}(\mathsf{Path}(a,b,s,x)) = x$
\item[] $\mathsf{pdec}(x) = \bot$, otherwise
\item[]
\item[] $\cdot : Hom(\theta)_\bot \times \D \to \D$
\item[] $m \cdot \mathsf{Lam}(f) = \mathsf{Lam}((m',x) \mapsto f(m \circ m', x))$
\item[] $m \cdot \mathsf{Pair}(a, b) = \mathsf{Pair}(m \cdot a, m \cdot b)$
\item[] $m \cdot \mathsf{U}(\alpha) = \mathsf{U}(\alpha)$
\item[] $m \cdot \mathsf{Ne}(s,e,c) = TODO$
\item[] $m \cdot \mathsf{Id}(A, a, a') = \mathsf{Id}(m \cdot A, m \cdot a, m \cdot a')$
\item[] $m \cdot \mathsf{Pi}(A, B) = \mathsf{Pi}(m \cdot A, m \cdot B)$
\item[] $m \cdot \mathsf{Sigma}(A, B) = \mathsf{Sigma}(m \cdot A, m \cdot B)$
\item[] $\alpha \cdot \mathsf{Tri}(a, b, c) = a$
\item[] $\beta \cdot \mathsf{Tri}(a, b, c) = b$
\item[] $\gamma \cdot \mathsf{Tri}(a, b, c) = c$
\item[] $m \cdot x = \bot$, otherwise
\end{itemize}

Now, let us define the composition function.
The second argument is the dimension of the cells which we compose, and the first one is the dimension of the cell along which we compose.
\begin{itemize}
\item[] $\mathsf{comp} : \nats_\bot \times \nats_\bot \times \D \times \D \to \D$
\item[] $\mathsf{comp}(k, n, \mathsf{Lam}(f), \mathsf{Lam}(f')) = \mathsf{Lam}(g)$, where \\
    \indent $g(\delta^n_{n'},a) = \mathsf{comp}(k, n', f(\delta^n_{n'}, \delta^{n'}_k \cdot \tau^k_{n'} \cdot a), f'(\delta^n_{n'}, a))$ \\
    \indent $g(\sigma^n_{n'},a) = f(\sigma^n_{n'},a)$ \\
    \indent $g(\tau^n_{n'},a) = f(\tau^n_{n'},a)$
\item[] $\mathsf{comp}(k, n, \mathsf{Pair}(a,b), \mathsf{Pair}(a',b')) = \mathsf{Pair}(\mathsf{comp}(k,n,a,a'), \mathsf{comp}(k,n,b,b'))$
\item[] $\mathsf{comp}(k, n, \mathsf{Path}(a,b,s,x), \mathsf{Path}(a',b',s',x')) = \mathsf{Path}(TODO)$
\item[] $\mathsf{comp}(k, n, \mathsf{Sigma}(A,B), \mathsf{Sigma}(A',B')) =$ \\
    \indent $\mathsf{Sigma}(\mathsf{comp}(k, n, A, A'), \mathsf{comp}(k, n, B, B'))$
\item[] $\mathsf{comp}(k, n, \mathsf{Pi}(A,B), \mathsf{Pi}(A',B')) = \mathsf{Pi}(\mathsf{comp}(k, n, A, A'), \mathsf{comp}(k, n, B, B'))$
\item[] $\mathsf{comp}(k, n, \mathsf{Id}(A,a,a'), \mathsf{Id}(B,b,b')) =$ \\
    \indent $\mathsf{Id}(\mathsf{comp}(k + 1, n + 1, A, B), \mathsf{comp}(k, n, a, b), \mathsf{comp}(k, n, a', b'))$
\item[] $\mathsf{comp}(k, n, \mathsf{Ne}(l,r,t,c), \mathsf{Ne}(l',r',t',c')) = \mathsf{Ne}(TODO)$
\item[] $\mathsf{comp}(k, n, \mathsf{U}(\alpha), \mathsf{U}(\beta)) = \mathsf{U}(max(\alpha,\beta))$
\item[] $\mathsf{comp}(k, n, x, x') = \bot$, otherwise
\end{itemize}

Let $\mathscr{P}(\D)$ denote the set of subset of $\D$.
If $n \in \nats$, $R \in \mathscr{P}(\D)$, $Q : \D \to \mathscr{P}(\D)$, and $x_0,x'_0 \in \D$,
then define $\mathcal{S}igma\,R\,Q, \mathcal{P}i_n R\,Q, \mathcal{N}\!e, \mathcal{I}d_n R\,x_0\,x'_0 \in \mathscr{P}(\D)$ as follows:
\[ \mathcal{S}igma\,R\,Q = \{ \mathsf{Pair}(a,b) \in \D\,|\,a \in R, b \in R(a) \}, \]
\[ \mathcal{P}i_n R\,Q = \{ \mathsf{Lam}(f) \in \D\,|\,f(id_n,a) \in Q(a) \text{ for all } a \in R \}, \]
\[ \mathcal{N}\!e = \{ \mathsf{Ne}(s,e,c)\,|\,e \in TM \}, \]
\[ \mathcal{I}d_n R\,x_0\,x'_0 = \{ \mathsf{Path}(x_0,x_0',[(x_1,x'_1), \ldots (x_n,x'_n)],x) \,|\, x \in R, \]
\[ \sigma_n \cdot x = d^0_{n,n}(x_n,x'_{n-1},x_{n-2},x'_{n-3},\ldots), \]
\[ \tau_n \cdot x = d^1_{n,n}(x'_n,x_{n-1},x'_{n-2},x_{n-3},\ldots) \}, \]
where $d^i_{n,k}$ are defined as follows: $d^i_{n,0}(a_0) = a_0$,
\[ d^i_{n,k+1}(a_0, \ldots a_{k+1}) = \left\{ \begin{array}{l l}
            d^i_{n,k}(a_0, \ldots a_{k-1}, \mathsf{comp}(k, n, \delta^n_{n-k} \cdot a_k, a_{k+1})) \text{, if $k \bmod 2 = i$} \\
            d^i_{n,k}(a_0, \ldots a_{k-1}, \mathsf{comp}(k, n, a_{k+1}, \delta^n_{n-k} \cdot a_k)) \text{, otherwise.}
    \end{array} \right. \]

Now, for each $\alpha \leq \omega$ and $n \in Ob(\theta)$,
we define $\mathcal{U}^\alpha_n \in \mathscr{P}(\D)$ and a function $[-]^\alpha_n : \mathcal{U}^\alpha_n \to \mathscr{P}(\D)$ by induction on $\alpha$.
First, we define a relation $G^\alpha_n \subseteq \D \times \mathscr{P}(\D)$ inductively by the following rules:
\medskip
\begin{center}
\AxiomC{$(A, R) \in G^\alpha_n$}
\AxiomC{$(\mathsf{app}(n, B, a), Q(a)) \in G^\alpha_n$ for all $a \in R$}
\BinaryInfC{$(\mathsf{Sigma}(A, B), \mathcal{S}igma\,R\,Q) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$(A, R) \in G^\alpha_n$}
\AxiomC{$(\mathsf{app}(n, B, a), Q(a)) \in G^\alpha_n$ for all $a \in R$}
\BinaryInfC{$(\mathsf{Pi}(A, B), \mathcal{P}i_n R\,Q) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$(A,R) \in G^\alpha_{n+1}$}
\UnaryInfC{$(\mathsf{Id}(A, a, a'), \mathcal{I}d_n R\,a\,a') \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{}
\UnaryInfC{$(\mathsf{Ne}(s,e,c), \mathcal{N}\!e) \in G^\alpha_n$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{, $\beta < \alpha$}
\UnaryInfC{$(\mathsf{U}(\beta), \mathcal{U}^\beta_n) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

We inductively define $\mathcal{U}^\alpha_n \in \mathscr{P}(\D)$ by the following rules:
\medskip
\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_n$}
\AxiomC{$\mathsf{app}(n, B, a) \in \mathcal{U}^\alpha_n$ for all $a \in [A]^\alpha_n$}
\BinaryInfC{$\mathsf{Sigma}(A, B) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_n$}
\AxiomC{$\mathsf{app}(n, B, a) \in \mathcal{U}^\alpha_n$ for all $a \in [A]^\alpha_n$}
\BinaryInfC{$\mathsf{Pi}(A, B) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_{n + 1}$}
\AxiomC{$a \in [\sigma_n \cdot A]^\alpha_n$}
\AxiomC{$a' \in [\tau_n \cdot A]^\alpha_n$}
\TrinaryInfC{$\mathsf{Id}(A, a, a') \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$s(i) \in \mathcal{U}^\alpha_i \times \mathcal{U}^\alpha_i$ for all $0 \leq i < n$}
\UnaryInfC{$\mathsf{Ne}(s,e,c) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\quad
\centerAlignProof
\AxiomC{}
\RightLabel{, $\beta < \alpha$}
\UnaryInfC{$\mathsf{U}(\beta) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip
We write simply $\mathcal{U}_n$ for $\mathcal{U}^\omega_n$ and $[-]_n$ for $[-]^\omega_n$.

\begin{lem}
For each $\alpha \leq \omega$ and $n \in Ob(\theta)$, the graph $G^\alpha_n$ defines a partial function, that is $(A, R), (A, R') \in G^\alpha_n$ implies $R = R'$.
For each $\alpha \leq \omega$ and $n \in Ob(\theta)$, the partial function $[-]^\alpha_n : \D \to \mathscr{P}(\D)$
defined by the graph $G^\alpha_n$ is defined on $\mathcal{U}^\alpha_n \subseteq \D$.
\end{lem}
\begin{proof}
The first statement is proved by induction on generation of $G^\alpha_n$ and the second by induction on generation of $\mathcal{U}^\alpha_n$.
\end{proof}

For each $n \in Ob(\theta)$ and context $\Gamma$ (that is, finite sequence of terms), we define its interpretation $[\Gamma]_n \subseteq Env$ as follows:
$\rho \in [\Gamma]_n$ if and only if $\rho(i) \in [\llbracket \Gamma(i) \rrbracket^\rho_n]_n$ for each $0 \leq i < |\Gamma|$.
We define a predicate on contexts $\Gamma \models$ inductively as follows:

\centerAlignProof

\medskip
\begin{center}
\AxiomC{}
\UnaryInfC{$\varnothing \models$}
\DisplayProof
\quad
\AxiomC{$\Gamma \models$}
\AxiomC{$\llbracket A \rrbracket^\rho_n \in \mathcal{U}_n$ for all $n \in Ob(\theta)$ and $\rho \in [\Gamma]_n$}
\BinaryInfC{$\Gamma, A \models$}
\DisplayProof
\end{center}
\medskip

We write $\Gamma \models a : A$ if and only if $\Gamma \models$, and for all $n \in Ob(\theta)$ and $\rho \in [\Gamma]_n$,
we have $\llbracket A \rrbracket^\rho_n \in \mathcal{U}_n$ and $\llbracket a \rrbracket^\rho_n \in [\llbracket A \rrbracket^\rho_n]_n$.

\begin{prop}
If $\Gamma \vdash$, then $\Gamma \models$.
If $\Gamma \vdash a : A$, then $\Gamma \models a : A$.
\end{prop}
\begin{proof}
By induction on the derivation.
Most of the cases are straightforward, let us prove some of them:
\begin{itemize}
\item Case
\AxiomC{$\Gamma, A \vdash b : B$}
\UnaryInfC{$\Gamma \vdash \lambda b : \Pi A B$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash b : \Pi A B$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash b\ a : B[a]$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash p : A = B\,|\,idp\ U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B$}
\TrinaryInfC{$\Gamma \vdash a = b\,|\,p : U_\alpha$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash a : A$}
\UnaryInfC{$\Gamma \vdash idp\ a : a = a\,|\,idp\ A$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B : U_\beta$}
\RightLabel{, $\llbracket A \rrbracket^{\rho_\Gamma}_0 = \llbracket B \rrbracket^{\rho_\Gamma}_0$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{itemize}
\end{proof}

\bibliographystyle{amsplain}
\bibliography{ref}

\end{document}
