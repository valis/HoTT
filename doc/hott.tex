\documentclass{amsart}

\usepackage{amssymb}
\usepackage[all]{xy}
\usepackage{verbatim}
\usepackage{ifthen}
\usepackage{xargs}
\usepackage{bussproofs}
\usepackage{stmaryrd}
\usepackage{mathrsfs}

\providecommand\WarningsAreErrors{false}
\ifthenelse{\equal{\WarningsAreErrors}{true}}{\renewcommand{\GenericWarning}[2]{\GenericError{#1}{#2}{}{This warning has been turned into a fatal error.}}}{}

\newcommand{\newref}[4][]{
\ifthenelse{\equal{#1}{}}{\newtheorem{h#2}[hthm]{#4}}{\newtheorem{h#2}{#4}[#1]}
\expandafter\newcommand\csname r#2\endcsname[1]{#3~\ref{#2:##1}}
\expandafter\newcommand\csname R#2\endcsname[1]{#4~\ref{#2:##1}}
\newenvironmentx{#2}[2][1=,2=]{
\ifthenelse{\equal{##2}{}}{\begin{h#2}}{\begin{h#2}[##2]}
\ifthenelse{\equal{##1}{}}{}{\label{#2:##1}}
}{\end{h#2}}
}

\newref[section]{thm}{theorem}{Theorem}
\newref{lem}{lemma}{Lemma}
\newref{prop}{proposition}{Proposition}
\newref{cor}{corollary}{Corollary}

\theoremstyle{definition}
\newref{defn}{definition}{Definition}
\newref{example}{example}{Example}

\theoremstyle{remark}
\newref{remark}{remark}{Remark}

\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand{\D}{\mathsf{D}}
\newcommand{\bbG}{\mathbb{G}}
\newcommand{\Set}{\cat{Set}}
\newcommand{\PSh}[1]{\Set^{#1^{op}}}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\glob}{\PSh{\bbG}}
\newcommand{\ocat}{\omega \cat{Cat}}
\newcommand{\Dn}[1][n]{\mathrm{D}^{#1}}
\newcommand{\dDn}[1][n]{\mathrm{\partial D}^{#1}}

\newcommand{\pb}[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}
\newcommand{\po}[1][dr]{\save*!/#1+1.2pc/#1:(1,-1)@^{|-}\restore}

\numberwithin{table}{section}

\begin{document}

\title{Homotopy Type Theory}

\author{Valery Isaev}

\begin{abstract}
In this paper, we give a description of an evaluation algorithm for homotopy type theory.
\end{abstract}

\maketitle

\section{Introduction}

\section{Cellular sets}

In this section, we will recall the definition of cellular sets.

\begin{defn}
A \emph{globular set} is a presheaf on the category $\bbG$, whose objects are natural numbers and morphisms are generated from
$\sigma_n,\tau_n : n \to n + 1$ subject to the equations
$\sigma_{n+1} \circ \sigma_n = \tau_{n+1} \circ \sigma_n$, $\sigma_{n+1} \circ \tau_n = \tau_{n+1} \circ \tau_n$.
A morphism of globular sets is a morphism of presheaves.
\end{defn}

Explicitly, a globular set is a sequence of sets $X_n$ together with maps $s_k,t_k : X_n \to X_k$ for each $k < n$ subject to equations.
Elements of $X_n$ are called $n$-cells. Given $n$-cell $x$, cells $s_k(x)$ and $t_k(x)$
are called the ($k$-dimensional) source and the target of $x$ respectively.
A pair of $n$-cells $x$ and $y$ are \emph{parallel} if $s_k(x) = s_k(y)$ and $t_k(x) = t_k(y)$ for each $k < n$.
The expression $x : a \to b$ stands for the following:
there is $n \in \nats$ such that $a$ and $b$ are (necessarily parallel) $n$-cells,
$x$ is an $(n+1)$-cell, $s_n(x) = a$, and $t_n(x) = b$.

For each $n \in \nats$, the globular set $\bbG(-,n)$ is denoted by $\Dn$.
The globular sets $\dDn$ together with the maps $\dDn \to \Dn$ are defined by induction on $n$.
$\dDn[0]$ is the initial object, and $\dDn[0] \to \Dn[0]$ is the unique morphism.
$\dDn[n+1]$ is the pushout $\Dn \amalg_{\dDn} \Dn$, and $\dDn[n+1] \to \Dn[n+1]$
is induced by the maps $(\sigma_n \circ -)$ and $(\tau_n \circ -)$.

\begin{defn}
A \emph{strict $\omega$-category} is a globular set equipped with the following operations.
\begin{itemize}
\item For each $n$-cell $x$, an $(n+1)$-cell $id_x : x \to x$ called the \emph{identity} on $x$.
\item For each $n,k \in \nats$ and for each pair of $n$-cells $x$,$y$ such that
$t_k(x) = s_k(y)$ (in this case we say $x$ and $y$ are \emph{$k$-composable}),
an $n$-cell $y *_k x$ called \emph{k-composite} of $x$ and $y$.
\end{itemize}
We often regard an $n$-cell $x$ as a cell of a dimension higher than $n$ iteratively applying $id$ to $x$.

The operations above must satisfy the following properties.
\begin{itemize}
\item If $x : a \to b$, $y : b \to c$ is a pair of $n$-composable $(n+1)$-cells, then $y *_n x : a \to c$.
\item If $k < n$ and $x : a \to b$, $y : c \to d$ is a pair of $k$-composable $(n+1)$-cells, then $y *_k x : c *_k a \to d *_k b$.
\item If $x,y,z$ are $n$-cells, then $(z *_k y) *_k x = z *_k (y *_k x)$, whenever it makes sense.
\item If $k < n$ and $x$ is an $n$-cell, then $t_k(x) *_k x = x = x *_k s_k(x)$.
\item If $k < n$ and $x$,$y$ is a pair of $k$-composable $n$-cells, then $id_y *_k id_x = id_{y *_k x}$.
\item If $x$,$y$,$z$,$u$ are $n$-cells and $m < k < n$, then $(x *_k y) *_m (z *_k u) = (x *_m z) *_k (y *_m u)$, whenever it makes sense.
\end{itemize}

An $\omega$-functor between a pair of $\omega$-categories is a morphism of
the underlying globular sets commuting with compositions and identities.
The category $\ocat$ has $\omega$-categories as objects and $\omega$-functors as morphisms.
\end{defn}

The forgetful functor $U : \ocat \to \glob$ has a left adjoint $F : \glob \to \ocat$.
Let us denote by $(T : \glob \to \glob, \eta_X : X \to T(X), \mu_X : T T(X) \to T(X))$ the monad $U \circ F$,
and by $\dDn_T$ and $\Dn_T$ the $\omega$-categories $T(\dDn)$ and $T(\Dn)$.

An \emph{$n$-dimensional pasting diagram} is defined by induction on $n$.
There is exactly one $0$-dimensional pasting diagram, which is denoted by $\diamond$.
An $(n+1)$-dimensional pasting diagram is a finite sequence of $n$-dimensional pasting diagrams.

With each $n$-dimensional pasting diagram $\pi$ we associate an $n$-dimensional globular set $\widehat{\pi}$.
If $\pi$ is the unique $0$-dimensional pasting diagram, then $\widehat{\pi}$ is the terminal $0$-dimensional globular set.
If $\pi = (\pi^1, \ldots \pi^k)$, then let $\widehat{\pi}_0 = \{0, 1, \ldots k\}$
and $\widehat{\pi}_{m+1} = \coprod \limits_{i = 1}^k \widehat{\pi^i}_m$.
For each $k > 0$, the source and the target are defined in the evident way,
and for each $x \in \widehat{\pi^i}$, we define $s_0(x) = i - 1$ and $t_0(x) = i$.

\begin{defn}
The category $\Theta$ has pasting diagrams as objects, and the set of morphisms between $\pi_1$ and $\pi_2$
is the set of morphisms between strict $\omega$-categories $T(\widehat{\pi_1})$ and $T(\widehat{\pi_2})$.
That is, $\Theta$ is a full subcategory of $\ocat$.
A cellular set is a presheaf on $\Theta$, a morphism of cellular sets is a morphism of presheaves.
\end{defn}

\section{Syntax and Inference Rules}

First, let us define the sets of raw terms and contexts:
\[ Tm ::= v_i\ |\ U_\alpha\ |\ \Pi\,A\,B\ |\ \lambda b\ |\ app\ n\ f\ a\ |\ \Sigma\,A\,B\ |\ a , b\ |\ proj_1\ n\ p\ |\ proj_2\ n\ p\ | \]
\[ (a = a' \,|\, A)\ |\ idp\ a\ |\ pmap\ p\ q\ |\ inv\ n\ p\ |\ comp\ k\ n\ p\ q\ |\ coe\ n\ p, \]
\[ Ctx ::= \epsilon\ |\ \Gamma, A, \]
where $i \in \Z$, $\alpha, k, n \in \nats$, $\Gamma \in Ctx$, and $a, a', b, f, p, q, t, A, B \in Tm$.
Similarly to \cite{norm}, we use de Bruijn's representation of lambda terms.

The meaning of each term should be clear from the inference rules listed in table \ref{table:inf-rules}.
Note that we do not use reduction rules, instead we define terms to be computationally equal if their interpretations coincide.
Thus inference rules depend on the evaluation function $\llbracket - \rrbracket$ that will be defined in section \ref{sec:eval}.

We write $\Pi_0 A\,B$ for $\Pi\,A\,B$, $\Sigma_0 A\,B$ for $\Sigma\,A\,B$, and $Id_0 A\,a\,a'$ for $a = a' | A$.
Define terms $\Pi_{n+1} A\,B$, $\Sigma_{n+1} A\,B$, and $Id_{n+1} A\,a\,a'$ as follows:
\[ \Pi_{n+1} A\,B = pmap\,(pmap\,(idp\ (\lambda \lambda \Pi_n\,v_1\,v_1))\,A)\,B, \]
\[ \Sigma_{n+1} A\,B = pmap\,(pmap\,(idp\ (\lambda \lambda \Sigma_n\,v_1\,v_1))\,A)\,B, \]
\[ Id_{n+1} A\,a\,a' = pmap\,(pmap\,(pmap\,(idp\ (\lambda \lambda \lambda Id_n\,v_2\,v_1\,v_0))\,A)\,a)\,a'. \]

\centerAlignProof

\begin{table}
\begin{center}
\AxiomC{}
\UnaryInfC{$\epsilon \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\UnaryInfC{$\Gamma, A \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $0 \leq i < | \Gamma |$}
\UnaryInfC{$\Gamma \vdash v_i : \Gamma(i)$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $\alpha < \beta$}
\UnaryInfC{$\Gamma \vdash U_\alpha : U_\beta$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\BinaryInfC{$\Gamma \vdash \Pi A B : U_{max(\alpha,\beta)}$}
\DisplayProof
\quad
\AxiomC{$\Gamma, A \vdash b : B$}
\UnaryInfC{$\Gamma \vdash \lambda b : \Pi A B$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash b : \Pi A B$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash app\ 0\ b\ a : B[a]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash A : U_\alpha$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\BinaryInfC{$\Gamma \vdash \Sigma\,A\,B : U_{max(\alpha,\beta)}$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B[a]$}
\AxiomC{$\Gamma, A \vdash B : U_\beta$}
\TrinaryInfC{$\Gamma \vdash a, b : \Sigma\,A\,B$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : \Sigma\,A\,B$}
\UnaryInfC{$\Gamma \vdash proj_1\ p : A$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash p : \Sigma\,A\,B$}
\UnaryInfC{$\Gamma \vdash proj_2\ p : B[proj_1\ p]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : A = B \,|\, idp\ U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B$}
\TrinaryInfC{$\Gamma \vdash a = b \,|\, p : U_\alpha$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash a : A$}
\UnaryInfC{$\Gamma \vdash idp\ a : a = a\,|\, idp\ A$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash b : b_0 = b_1\,|\,\Pi_1\,A\,B$}
\AxiomC{$\Gamma \vdash a : a_0 = a_1\,|\,A$}
\BinaryInfC{$\Gamma \vdash pmap\ b\ a : b_0\ a_0 = b_1\ a_1\,|\,B[a]$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash p : A = B \,|\, idp\ U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash coe\ 0\ p\ a : B$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B : U_\beta$}
\RightLabel{, $\mathsf{reify}(0, \llbracket A \rrbracket^{\rho_\Gamma}_0, \mathsf{U}(\omega)) = \mathsf{reify}(0, \llbracket B \rrbracket^{\rho_\Gamma}_0, \mathsf{U}(\omega))$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{center}

\bigskip
\caption{Inference rules.}
\label{table:inf-rules}
\end{table}

\section{Evaluation}
\label{sec:eval}

We work in a suitable category of domains (see, for example, \cite{domains} for more information on the topic).
Let $TM$ be the set of functions $\nats \to Tm$, $Ob(\theta)$ the set of objects, and $Hom(\theta)$ the set of morphisms of the category $\theta$.
Let $(\D,\sqsubseteq)$ be a domain satisfying the following equation:
\[ \D = [Hom(\theta)_\bot \times \D \to \D] \oplus \D \times \D \oplus (\omega + 1)_\bot \oplus \D \times \D \times \mathsf{List}(\D \times \D) \times \D \]
\[ \oplus \D \times \D \times TM_\bot \times \nats_\bot \oplus \D \times \D \times \D \oplus \D \times \D \times \D \oplus \D \times \D \oplus \D \times \D, \]
where $\omega + 1$ denotes the set $\nats \cup \{ \omega \}$, and $\mathsf{List}(\D \times \D)$ is a domain of finite sequences of elements of $\D \times \D$.
We introduce the following names for the constructors:
\begin{itemize}
\item[] $\mathsf{Lam} : [Hom(\theta)_\bot \times \D \to \D] \to \D$
\item[] $\mathsf{Pair} : \D \times \D \to \D$
\item[] $\mathsf{U} : (\omega + 1)_\bot \to \D$
\item[] $\mathsf{Path} : \D \times \D \times \mathsf{List}(\D \times \D) \times \D \to \D$
\item[] $\mathsf{Ne} : \D \times \D \times TM_\bot \times \nats_\bot \to \D$
\item[] $\mathsf{Tri} : \D \times \D \times \D \to \D$
\item[] $\mathsf{Id} : \D \times \D \times \D \to \D$
\item[] $\mathsf{Pi} : \D \times \D \to \D$
\item[] $\mathsf{Sigma} : \D \times \D \to \D$
\end{itemize}

Let $Env$ be the domain $[\nats_\bot \to \D]$.
If $\rho \in Env$ and $x \in \D$, then we define $\rho[x] \in Env$ to be the function defined by the following rules: $\rho[x](0) = x$ and $\rho[x](i+1) = \rho(i)$.
Now, we define a part of the evaluation function, the rest of the cases will be defined later.
\begin{itemize}
\item[] $\llbracket - \rrbracket : Tm_\bot \times Env \times Ob(\theta)_\bot \to \D$
\item[] $\llbracket v_i \rrbracket^\rho_n = \rho(i)$, if $i \geq 0$, and $\bot$, otherwise.
\item[] $\llbracket U_\alpha \rrbracket^\rho_n = \mathsf{U}(\alpha)$
\item[] $\llbracket \lambda b \rrbracket^\rho_n = \mathsf{Lam}((m, a) \mapsto \llbracket b \rrbracket^{(i \mapsto m \cdot \rho(i))[a]}_{dom(m)})$
\item[] $\llbracket b\ a \rrbracket^\rho_n = \mathsf{app}(n, \llbracket b \rrbracket^\rho_n, \llbracket a \rrbracket^\rho_n)$
\item[] $\llbracket a, b \rrbracket^\rho_n = \mathsf{Pair}(\llbracket a \rrbracket^\rho_n, \llbracket b \rrbracket^\rho_n)$
\item[] $\llbracket proj_1\ p \rrbracket^\rho_n = \mathsf{proj_1}(\llbracket p \rrbracket^\rho_n)$
\item[] $\llbracket proj_2\ p \rrbracket^\rho_n = \mathsf{proj_2}(\llbracket p \rrbracket^\rho_n)$
\end{itemize}

\begin{comment}
\item[] $\llbracket \Pi A B \rrbracket^\rho_n = \mathsf{Pi}(\llbracket A \rrbracket^\rho_n, \mathsf{Lam}((m, a) \mapsto \llbracket B \rrbracket^{(i \mapsto m \cdot \rho(i))[a]}_{dom(m)}))$
\item[] $\llbracket \Sigma A B \rrbracket^\rho_n = \mathsf{Sigma}(\llbracket A \rrbracket^\rho_n, \mathsf{Lam}((m, a) \mapsto \llbracket B \rrbracket^{(i \mapsto m \cdot \rho(i))[a]}_{dom(m)}))$
\item[] $\llbracket a = a' | A \rrbracket^\rho_n = \mathsf{Id}(\mathsf{pdec}(\llbracket A \rrbracket^\rho_n), \llbracket a \rrbracket^\rho_n, \llbracket a' \rrbracket^\rho_n)$
\item[] $\llbracket idp\ a \rrbracket^\rho_n = \mathsf{Path}([(a_0, a'_0), \ldots (a_{n-1}, a'_{n-1})], \delta_n \cdot \llbracket a \rrbracket^\rho_n)$, \\
    \indent where $a_k  = \delta_k \cdot \llbracket a \rrbracket^{i \mapsto \sigma^k_n \cdot \rho(i)}_k$ and
                  $a'_k = \delta_k \cdot \llbracket a \rrbracket^{i \mapsto \tau^k_n \cdot \rho(i)}_k$
\item[] $\llbracket pmap\ b\ a \rrbracket^\rho_n = \mathsf{Path}([(x_0,x'_0), \ldots (x_{n-1},x'_{n-1}))], x)$, \\
    \indent where $x = \mathsf{app}(n + 1, \mathsf{pdec}(\llbracket b \rrbracket^\rho_n), \mathsf{pdec}(\llbracket a \rrbracket^\rho_n))$, \\
    \indent \indent $x_k = \mathsf{app}(k + 1, \mathsf{pdec}(\llbracket b \rrbracket^{i \mapsto \sigma^k_n \cdot \rho(i)}_k), \mathsf{pdec}(\llbracket a \rrbracket^{i \mapsto \sigma^k_n \cdot \rho(i)}_k))$, and \\
    \indent \indent $x'_k = \mathsf{app}(k + 1, \mathsf{pdec}(\llbracket b \rrbracket^{i \mapsto \tau^k_n \cdot \rho(i)}_k), \mathsf{pdec}(\llbracket a \rrbracket^{i \mapsto \tau^k_n \cdot \rho(i)}_k))$
\end{comment}

Functions $\mathsf{app}$, $\mathsf{proj_1}$, $\mathsf{proj_2}$, and $\cdot$ are defined as follows:
\begin{itemize}
\item[] $\mathsf{app} : Ob(\theta)_\bot \times \D \times \D \to \D$
\item[] $\mathsf{app}(n,\mathsf{Lam}(f),a) = f(id_n,a)$
\item[] $\mathsf{app}(n,e,a) = \bot$, otherwise
\item[]
\item[] $\mathsf{proj_1} : \D \to \D$
\item[] $\mathsf{proj_1}(\mathsf{Pair}(a,b)) = a$
\item[] $\mathsf{proj_1}(x) = \bot$, otherwise
\item[]
\item[] $\mathsf{proj_2} : \D \to \D$
\item[] $\mathsf{proj_2}(\mathsf{Pair}(a,b)) = b$
\item[] $\mathsf{proj_2}(x) = \bot$, otherwise
\item[]
\item[] $\mathsf{pdec} : \D \to \D$
\item[] $\mathsf{pdec}(\mathsf{Path}(a,b,s,x)) = x$
\item[] $\mathsf{pdec}(x) = \bot$, otherwise
\item[]
\item[] $\cdot : Hom(\theta)_\bot \times \D \to \D$
\item[] $m \cdot \mathsf{Lam}(f) = \mathsf{Lam}((m',x) \mapsto f(m \circ m', x))$
\item[] $m \cdot \mathsf{Pair}(a, b) = \mathsf{Pair}(m \cdot a, m \cdot b)$
\item[] $m \cdot \mathsf{U}(\alpha) = \mathsf{U}(\alpha)$
\item[] $m \cdot \mathsf{Ne}(s,e,c) = TODO$
\item[] $m \cdot \mathsf{Id}(A, a, a') = \mathsf{Id}(m \cdot A, m \cdot a, m \cdot a')$
\item[] $m \cdot \mathsf{Pi}(A, B) = \mathsf{Pi}(m \cdot A, m \cdot B)$
\item[] $m \cdot \mathsf{Sigma}(A, B) = \mathsf{Sigma}(m \cdot A, m \cdot B)$
\item[] $\alpha \cdot \mathsf{Tri}(a, b, c) = a$
\item[] $\beta \cdot \mathsf{Tri}(a, b, c) = b$
\item[] $\gamma \cdot \mathsf{Tri}(a, b, c) = c$
\item[] $m \cdot x = \bot$, otherwise
\end{itemize}

Now, let us define the composition function.
The second argument is the dimension of the cells which we compose, and the first one is the dimension of the cell along which we compose.
\begin{itemize}
\item[] $\mathsf{comp} : \nats_\bot \times \nats_\bot \times \D \times \D \to \D$
\item[] $\mathsf{comp}(k, n, \mathsf{Lam}(f), \mathsf{Lam}(f')) = \mathsf{Lam}(g)$, where \\
    \indent $g(\delta^n_{n'},a) = \mathsf{comp}(k, n', f(\delta^n_{n'}, \delta^{n'}_k \cdot \tau^k_{n'} \cdot a), f'(\delta^n_{n'}, a))$ \\
    \indent $g(\sigma^n_{n'},a) = f(\sigma^n_{n'},a)$ \\
    \indent $g(\tau^n_{n'},a) = f(\tau^n_{n'},a)$
\item[] $\mathsf{comp}(k, n, \mathsf{Pair}(a,b), \mathsf{Pair}(a',b')) = \mathsf{Pair}(\mathsf{comp}(k,n,a,a'), \mathsf{comp}(k,n,b,b'))$
\item[] $\mathsf{comp}(k, n, \mathsf{Path}(a,b,s,x), \mathsf{Path}(a',b',s',x')) = \mathsf{Path}(TODO)$
\item[] $\mathsf{comp}(k, n, \mathsf{Sigma}(A,B), \mathsf{Sigma}(A',B')) =$ \\
    \indent $\mathsf{Sigma}(\mathsf{comp}(k, n, A, A'), \mathsf{comp}(k, n, B, B'))$
\item[] $\mathsf{comp}(k, n, \mathsf{Pi}(A,B), \mathsf{Pi}(A',B')) = \mathsf{Pi}(\mathsf{comp}(k, n, A, A'), \mathsf{comp}(k, n, B, B'))$
\item[] $\mathsf{comp}(k, n, \mathsf{Id}(A,a,a'), \mathsf{Id}(B,b,b')) =$ \\
    \indent $\mathsf{Id}(\mathsf{comp}(k + 1, n + 1, A, B), \mathsf{comp}(k, n, a, b), \mathsf{comp}(k, n, a', b'))$
\item[] $\mathsf{comp}(k, n, \mathsf{Ne}(l,r,t,c), \mathsf{Ne}(l',r',t',c')) = \mathsf{Ne}(TODO)$
\item[] $\mathsf{comp}(k, n, \mathsf{U}(\alpha), \mathsf{U}(\beta)) = \mathsf{U}(max(\alpha,\beta))$
\item[] $\mathsf{comp}(k, n, x, x') = \bot$, otherwise
\end{itemize}

Let $\mathscr{P}(\D)$ denote the set of subset of $\D$.
If $n \in \nats$, $R \in \mathscr{P}(\D)$, $Q : \D \to \mathscr{P}(\D)$, and $x_0,x'_0 \in \D$,
then define $\mathcal{S}igma\,R\,Q, \mathcal{P}i_n R\,Q, \mathcal{N}\!e, \mathcal{I}d_n R\,x_0\,x'_0 \in \mathscr{P}(\D)$ as follows:
\[ \mathcal{S}igma\,R\,Q = \{ \mathsf{Pair}(a,b) \in \D\,|\,a \in R, b \in R(a) \}, \]
\[ \mathcal{P}i_n R\,Q = \{ \mathsf{Lam}(f) \in \D\,|\,f(id_n,a) \in Q(a) \text{ for all } a \in R \}, \]
\[ \mathcal{N}\!e = \{ \mathsf{Ne}(s,e,c)\,|\,e \in TM \}, \]
\[ \mathcal{I}d_n R\,x_0\,x'_0 = \{ \mathsf{Path}(x_0,x_0',[(x_1,x'_1), \ldots (x_n,x'_n)],x) \,|\, x \in R, \]
\[ \sigma_n \cdot x = d^0_{n,n}(x_n,x'_{n-1},x_{n-2},x'_{n-3},\ldots), \]
\[ \tau_n \cdot x = d^1_{n,n}(x'_n,x_{n-1},x'_{n-2},x_{n-3},\ldots) \}, \]
where $d^i_{n,k}$ are defined as follows: $d^i_{n,0}(a_0) = a_0$,
\[ d^i_{n,k+1}(a_0, \ldots a_{k+1}) = \left\{ \begin{array}{l l}
            d^i_{n,k}(a_0, \ldots a_{k-1}, \mathsf{comp}(k, n, \delta^n_{n-k} \cdot a_k, a_{k+1})) \text{, if $k \bmod 2 = i$} \\
            d^i_{n,k}(a_0, \ldots a_{k-1}, \mathsf{comp}(k, n, a_{k+1}, \delta^n_{n-k} \cdot a_k)) \text{, otherwise.}
    \end{array} \right. \]

Now, for each $\alpha \leq \omega$ and $n \in Ob(\theta)$,
we define $\mathcal{U}^\alpha_n \in \mathscr{P}(\D)$ and a function $[-]^\alpha_n : \mathcal{U}^\alpha_n \to \mathscr{P}(\D)$ by induction on $\alpha$.
First, we define a relation $G^\alpha_n \subseteq \D \times \mathscr{P}(\D)$ inductively by the following rules:
\medskip
\begin{center}
\AxiomC{$(A, R) \in G^\alpha_n$}
\AxiomC{$(\mathsf{app}(n, B, a), Q(a)) \in G^\alpha_n$ for all $a \in R$}
\BinaryInfC{$(\mathsf{Sigma}(A, B), \mathcal{S}igma\,R\,Q) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$(A, R) \in G^\alpha_n$}
\AxiomC{$(\mathsf{app}(n, B, a), Q(a)) \in G^\alpha_n$ for all $a \in R$}
\BinaryInfC{$(\mathsf{Pi}(A, B), \mathcal{P}i_n R\,Q) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$(A,R) \in G^\alpha_{n+1}$}
\UnaryInfC{$(\mathsf{Id}(A, a, a'), \mathcal{I}d_n R\,a\,a') \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{}
\UnaryInfC{$(\mathsf{Ne}(s,e,c), \mathcal{N}\!e) \in G^\alpha_n$}
\DisplayProof
\quad
\AxiomC{}
\RightLabel{, $\beta < \alpha$}
\UnaryInfC{$(\mathsf{U}(\beta), \mathcal{U}^\beta_n) \in G^\alpha_n$}
\DisplayProof
\end{center}
\medskip

We inductively define $\mathcal{U}^\alpha_n \in \mathscr{P}(\D)$ by the following rules:
\medskip
\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_n$}
\AxiomC{$\mathsf{app}(n, B, a) \in \mathcal{U}^\alpha_n$ for all $a \in [A]^\alpha_n$}
\BinaryInfC{$\mathsf{Sigma}(A, B) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_n$}
\AxiomC{$\mathsf{app}(n, B, a) \in \mathcal{U}^\alpha_n$ for all $a \in [A]^\alpha_n$}
\BinaryInfC{$\mathsf{Pi}(A, B) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$A \in \mathcal{U}^\alpha_{n + 1}$}
\AxiomC{$a \in [\sigma_n \cdot A]^\alpha_n$}
\AxiomC{$a' \in [\tau_n \cdot A]^\alpha_n$}
\TrinaryInfC{$\mathsf{Id}(A, a, a') \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip

\begin{center}
\AxiomC{$s(i) \in \mathcal{U}^\alpha_i \times \mathcal{U}^\alpha_i$ for all $0 \leq i < n$}
\UnaryInfC{$\mathsf{Ne}(s,e,c) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\quad
\centerAlignProof
\AxiomC{}
\RightLabel{, $\beta < \alpha$}
\UnaryInfC{$\mathsf{U}(\beta) \in \mathcal{U}^\alpha_n$}
\DisplayProof
\end{center}
\medskip
We write simply $\mathcal{U}_n$ for $\mathcal{U}^\omega_n$ and $[-]_n$ for $[-]^\omega_n$.

\begin{lem}
For each $\alpha \leq \omega$ and $n \in Ob(\theta)$, the graph $G^\alpha_n$ defines a partial function, that is $(A, R), (A, R') \in G^\alpha_n$ implies $R = R'$.
For each $\alpha \leq \omega$ and $n \in Ob(\theta)$, the partial function $[-]^\alpha_n : \D \to \mathscr{P}(\D)$
defined by the graph $G^\alpha_n$ is defined on $\mathcal{U}^\alpha_n \subseteq \D$.
\end{lem}
\begin{proof}
The first statement is proved by induction on generation of $G^\alpha_n$ and the second by induction on generation of $\mathcal{U}^\alpha_n$.
\end{proof}

For each $n \in Ob(\theta)$ and context $\Gamma$ (that is, finite sequence of terms), we define its interpretation $[\Gamma]_n \subseteq Env$ as follows:
$\rho \in [\Gamma]_n$ if and only if $\rho(i) \in [\llbracket \Gamma(i) \rrbracket^\rho_n]_n$ for each $0 \leq i < |\Gamma|$.
We define a predicate on contexts $\Gamma \models$ inductively as follows:

\centerAlignProof

\medskip
\begin{center}
\AxiomC{}
\UnaryInfC{$\epsilon \models$}
\DisplayProof
\quad
\AxiomC{$\Gamma \models$}
\AxiomC{$\llbracket A \rrbracket^\rho_n \in \mathcal{U}_n$ for all $n \in Ob(\theta)$ and $\rho \in [\Gamma]_n$}
\BinaryInfC{$\Gamma, A \models$}
\DisplayProof
\end{center}
\medskip

We write $\Gamma \models a : A$ if and only if $\Gamma \models$, and for all $n \in Ob(\theta)$ and $\rho \in [\Gamma]_n$,
we have $\llbracket A \rrbracket^\rho_n \in \mathcal{U}_n$ and $\llbracket a \rrbracket^\rho_n \in [\llbracket A \rrbracket^\rho_n]_n$.

\begin{prop}
If $\Gamma \vdash$, then $\Gamma \models$.
If $\Gamma \vdash a : A$, then $\Gamma \models a : A$.
\end{prop}
\begin{proof}
By induction on the derivation.
Most of the cases are straightforward, let us prove some of them:
\begin{itemize}
\item Case
\AxiomC{$\Gamma, A \vdash b : B$}
\UnaryInfC{$\Gamma \vdash \lambda b : \Pi A B$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash b : \Pi A B$}
\AxiomC{$\Gamma \vdash a : A$}
\BinaryInfC{$\Gamma \vdash b\ a : B[a]$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash p : A = B\,|\,idp\ U_\alpha$}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash b : B$}
\TrinaryInfC{$\Gamma \vdash a = b\,|\,p : U_\alpha$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash a : A$}
\UnaryInfC{$\Gamma \vdash idp\ a : a = a\,|\,idp\ A$}
\DisplayProof \\

\item Case
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B : U_\beta$}
\RightLabel{, $\llbracket A \rrbracket^{\rho_\Gamma}_0 = \llbracket B \rrbracket^{\rho_\Gamma}_0$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{itemize}
\end{proof}

Now, let us show how to reify elements of $\D$ into terms.
\begin{itemize}
\item[] $\mathsf{reify} : \nats_\bot \times \D \times \D \to Tm_\bot$
\item[] $\mathsf{reify}(i, \mathsf{Lam}(f), \mathsf{Pi}(A, B)) = \lambda\,\mathsf{reify}(i + 1, f(id_0, x), \mathsf{app}(0, B, x))$, \\
        \indent where $x = \mathsf{reflect}(k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, \mathsf{Pair}(a, b), \mathsf{Sigma}(A, B)) = \mathsf{reify}(i, a, A), \mathsf{reify}(i, b, \mathsf{app}(0, B, a))$
\item[] $\mathsf{reify}(i, \mathsf{Path}(a, b, s, x), \mathsf{Id}(A, a', b')) = \mathsf{reify}(i, x, A)$
\item[] $\mathsf{reify}(i, \mathsf{U}(\alpha), \mathsf{U}(\beta)) = U_\alpha$, if $\alpha < \beta$
\item[] $\mathsf{reify}(i, \mathsf{Ne}(s, e, c), t) = e(i)$
\item[] $\mathsf{reify}(i, \mathsf{Id}(A, a, a'), \mathsf{U}(\alpha)) = (\mathsf{reify}(i, a, A) = \mathsf{reify}(i, a', A)\,|\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))$)
\item[] $\mathsf{reify}(i, \mathsf{Pi}(A, B), \mathsf{U}(\alpha)) =$
        $\Pi\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))\,\mathsf{reify}(i + 1, \mathsf{app}(0, B, x), \mathsf{U}(\alpha))$, \\
        \indent where $x = \mathsf{reflect}(k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, \mathsf{Sigma}(A, B), \mathsf{U}(\alpha)) = $
        $\Sigma\,\mathsf{reify}(i, A, \mathsf{U}(\alpha))\,\mathsf{reify}(i + 1, \mathsf{app}(0, B, x), \mathsf{U}(\alpha))$, \\
        \indent where $x = \mathsf{reflect}(k \mapsto v_{k - i - 1}, A)$
\item[] $\mathsf{reify}(i, e, t) = \bot$, otherwise
\item[]
\item[] $\mathsf{reflect} : TM_\bot \times \D \to \D$
\item[] $\mathsf{reflect}(e,\mathsf{Pi}(A, B)) = \mathsf{Lam}((m, a) \mapsto \mathsf{reflect}(k \mapsto e(k)\ \mathsf{reify}(0, a, A), \mathsf{app}(0, B, a)))$
\item[] $\mathsf{reflect}(e,\mathsf{Sigma}(A, B)) = \mathsf{Pair}(a, \mathsf{reflect}(k \mapsto proj_2\ e(k), \mathsf{app}(0, B, a)))$, \\
        \indent where $a = \mathsf{reflect}(k \mapsto proj_1\ e(k), A)$
\item[] $\mathsf{reflect}(e,t) = Ne(n \mapsto \bot, e, 0)$, otherwise
\end{itemize}

\bibliographystyle{amsplain}
\bibliography{ref}

\end{document}
