-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parser.ParGrammar where
import Parser.AbsGrammar
import Parser.LexGrammar
import Parser.ErrM

}

%name pDefs Defs

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '(' { PT _ (TS _ 1) }
 ')' { PT _ (TS _ 2) }
 '*' { PT _ (TS _ 3) }
 '->' { PT _ (TS _ 4) }
 ':' { PT _ (TS _ 5) }
 ';' { PT _ (TS _ 6) }
 '=' { PT _ (TS _ 7) }
 'Nat' { PT _ (TS _ 8) }
 'R' { PT _ (TS _ 9) }
 '\\' { PT _ (TS _ 10) }
 '_' { PT _ (TS _ 11) }
 'idp' { PT _ (TS _ 12) }
 'pmap' { PT _ (TS _ 13) }
 'suc' { PT _ (TS _ 14) }

L_integ  { PT _ (TI $$) }
L_U { PT _ (T_U $$) }
L_PIdent { PT _ (T_PIdent _) }
L_err    { _ }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
U    :: { U} : L_U { U ($1)}
PIdent    :: { PIdent} : L_PIdent { PIdent (mkPosToken $1)}

Defs :: { Defs }
Defs : ListDef { Defs $1 } 


Def :: { Def }
Def : PIdent ListArg '=' Expr { Def $1 (reverse $2) $4 } 
  | PIdent ':' Expr { DefType $1 $3 }


ListDef :: { [Def] }
ListDef : {- empty -} { [] } 
  | Def { (:[]) $1 }
  | Def ';' ListDef { (:) $1 $3 }


Expr :: { Expr }
Expr : '\\' ListBinder '->' Expr { Lam $2 $4 } 
  | Expr1 { $1 }


Expr1 :: { Expr }
Expr1 : Expr3 '->' Expr1 { Arr $1 $3 } 
  | ListTypedVar '->' Expr1 { Pi $1 $3 }
  | Expr2 { $1 }


Expr2 :: { Expr }
Expr2 : Expr3 '*' Expr2 { Prod $1 $3 } 
  | ListTypedVar '*' Expr2 { Sigma $1 $3 }
  | Expr3 { $1 }


Expr3 :: { Expr }
Expr3 : Expr4 '=' Expr4 { Id $1 $3 } 
  | Expr4 { $1 }


Expr4 :: { Expr }
Expr4 : Expr4 Expr5 { App $1 $2 } 
  | Expr5 { $1 }


Expr5 :: { Expr }
Expr5 : Arg { Var $1 } 
  | 'Nat' { Nat }
  | 'suc' { Suc }
  | 'R' { Rec }
  | 'idp' { Idp }
  | 'pmap' Expr5 { Pmap $2 }
  | Integer { NatConst $1 }
  | U { Universe $1 }
  | '(' Expr ')' { $2 }


Arg :: { Arg }
Arg : PIdent { Arg $1 } 
  | '_' { NoArg }


ListArg :: { [Arg] }
ListArg : {- empty -} { [] } 
  | ListArg Arg { flip (:) $1 $2 }


Binder :: { Binder }
Binder : Arg { Binder $1 } 


ListBinder :: { [Binder] }
ListBinder : Binder { (:[]) $1 } 
  | Binder ListBinder { (:) $1 $2 }


TypedVar :: { TypedVar }
TypedVar : '(' Expr ':' Expr ')' { TypedVar $2 $4 } 


ListTypedVar :: { [TypedVar] }
ListTypedVar : TypedVar { (:[]) $1 } 
  | TypedVar ListTypedVar { (:) $1 $2 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

